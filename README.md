# ekzamen-3-sem
1) Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента.
Реализация функции удаления элемента из двусвязного списка. Основные методы std::list.
Пример работы с std::list
2) Класс std::map. Внутренняя реализация map, его основные методы. Сложность поиска,
сортировки, удаления элемента, добавления элемента. Пример работы с std::map
3) Класс std::set. Внутренняя реализация set, его основные методы. Сложность поиска,
сортировки, удаления элемента, добавления элемента. Пример работы с std::set
4) Класс std::unordered_map. Внутренняя реализация unordered_map, его основные методы.
Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с
std:: unordered_map
5) Класс std::vector. Внутренняя реализация vector, его основные методы. Сложность поиска,
сортировки, удаления элемента, добавления элемента. Пример работы с std::vector.
Особенность std::vector<bool>.
6) Парадигмы ООП. Полиморфизм (статический, динамический). Инкапсуляция.
Наследование. Примеры.
7) Разработка обобщенных типов: шаблоны С++. Инстанцирование. Спецификация
шаблонов. Примеры.
8) Итераторы: определение, назначение, преимущества. Итераторы прямого доступа,
итераторы ввода, итераторы вывода, двунаправленные итераторы, прямой итератор.
Примеры.
9) Современный С++: auto, decltype, range base loop, nullptr, constexpr, enum class, if constexpr.
10) Современный С++: static_assert, initializer_list, default, final, override, using
11) Современный С++: std::optional, std::variant, std::any, std::string_view. Примеры
использования
12) Лямбда-функции, функторы, указатели на функции, std::functional. Примеры
использования std::functional. Примеры использования лямбда-функций.
13) R-value ссылки. Семантика перемещения. std::move, std::forward. Пример.
14) Обработка ошибок с использованием механизма обработки исключений. RAII. Примеры
классов, использующих RAII. Ключевое слово noexcept.
15) RAII. «Умные» указатели. std::shared_ptr. Примеры.
16) RAII. «Умные» указатели. std::unique_ptr. Примеры.
17) RAII. «Умные» указатели. std::weak_ptr. Примеры.
18) Сетевое взаимодействие. Berkley sockets. Основные функции для работы с сокетами
19) Сетевое взаимодействие. Сокеты. Библиотека boost asio.
20) Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future,
функция std::async.
21) Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры
использования thread_local.
22) Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры
использования std::thread.
23) Синхронизация потоков. Состояние гонок. Классы std::mutex, std::lock_guard,
std::unique_lock. Функция std::lock. Примеры использования мьютексов.
24) Синхронизация потоков. Состояние гонок. Классы std::recursive_mutex,
boost::shared_mutex, std::unique_lock. Функция std::lock. Пример использования
std::unique_lock
25) Класс std::condition_variable. Потокобезопасные структуры данных с блокировками.
26) Синхронизация потоков. Пул потоков. Класс std::condition_variable. Примеры работы с
std::condition_variable
  27) Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future,
функция std::async
  28) Атомарные операции. Классы std::atomic, std::atomic_flag. Примеры работы с std::atomic
  29) Шаблоны проектирования: фабричный метод. Пример реализации «простой фабрики» и
«фабричного метода».
  30) Шаблоны проектирования: observer. Пример реализации «обозреватель».
  31) Шаблоны проектирования: синглтон. Пример реализации Синглтона.
  32) Асинхронное программирование. Плюсы и минусы. Сопрограммы. Функции обратного
вызова.
  33) Атомарные операции. Классы std::atomic. Структуры данных без блокировок.
Реализация lock-free stack
  
  
