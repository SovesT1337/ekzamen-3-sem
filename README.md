# ekzamen-3-sem
## 1) Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента. Реализация функции удаления элемента из двусвязного списка. Основные методы std::list. Пример работы с std::list

Каждый узел двусвязного линейного списка содержит два поля указателей — на следующий и на предыдущий узлы. Указатель на предыдущий узел корня списка содержит нулевое значение. Указатель на следующий узел последнего узла также содержит нулевое значение.

Поиск элемента по значению
Сложность O(n). Проходим по всему списку и сравниваем каждый элемент с данным значением.

Вставка элемента
Сложность O(n). Сначала находим нужный элемент, затем создаём либо новый узел. Затем изменяем все указатели.

Удалениие элемента
Сложность O(n). Аналогично вставке.

Сортировка
Для сортировки вставками алгоритмическая сложность будет равна O(n^2), т.к необходми пройти по всему списку и каждый раз вставлять элементы перед требуемым. Соответственно n^2 проходов.

Реализация удаления:

```cpp
struct node {
    void *value;
    node *next;
    node *prev;
};

struct list {
    size_t size;
    node *head;
    node *tail;
};

void* deleteNth(list *_list, size_t index) {
    node *elm = _list->head;
    void *tmp = nullptr;
    size_t i = 0;
    while (elm && i < index) {
        elm = elm->next;
        i++;
    }
    if (elm == nullptr) {
        exit(5);
    }
    if (elm->prev) {
        elm->prev->next = elm->next;
    }
    if (elm->next) {
        elm->next->prev = elm->prev;
    }
    tmp = elm->value;
    if (!elm->prev) {
        _list->head = elm->next;
    }
    if (!elm->next) {
        _list->tail = elm->prev;
    }
    delete elm;
    _list->size--;
    return tmp;
}
```

std::list - двусвязный список.

##### Вместимость

| Метод | Функция |
| --- | --- |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |

##### Модификаторы

| Метод | Функция |
| --- | --- |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11)  | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| erase | Удаляет элементы
| push_back | добавляет элемент в конец |
| emplace_back  (C++11) | Конструирует элементы "на месте" в конце контейнера |
| pop_back | Удаляет последний элемент |
| push_front | вставляет элементы в начало списка |
| emplace_front  (C++11) | конструирует элементы "на месте" в начало списка |
| pop_front | удаляет первый элемент |
| resize | Изменяет количество хранимых элементов |
| (public функция-член) | swap |
| Обменивает содержимое | (public функция-член) |

##### Операции

| Метод | Функция |
| --- | --- |
| merge | слияние двух отсортированных списков |
| splice | перемещает элементы из другого list |
| remove / remove_if | удаляет элементы, удовлетворяющие определенным критериям |
| reverse | инвертирует порядок элементов |
| unique | удаляются последовательно повторяющиеся элементы |
| sort | сортирует элементы |

Пример работы с std::list:

```cpp
std::list<int> numbers{ 1, 2, 4, 5 }; // Инициализация
if (numbers.empty())
    std::cout << "The list is empty" << std::endl;
else
    std::cout << "The list is not empty" << std::endl;
numbers.push_back(23);  // { 1, 2, 3, 4, 5, 23 }
numbers.push_front(15); // { 15, 1, 2, 3, 4, 5, 23 }
```

## 2) Класс std::map. Внутренняя реализация map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::map

std::map — отсортированный ассоциативный контейнер, который содержит пары ключ-значение с неповторяющимися ключами. Порядок ключей задаётся функцией сравнения Compare. Операции поиска, удаления и вставки имеют логарифмическую сложность. Данный тип, как правило, реализуется как красно-чёрное дерево.

Красно-чёрное дерево — один из видов из самобалансирующихся двоичных деревьев поиска, гарантирующих логарифмический рост высоты дерева от числа узлов и позволяющее быстро выполнять основные операции дерева поиска: добавление, удаление и поиск узла. Сбалансированность достигается за счёт введения дополнительного атрибута узла дерева — «цвета». Этот атрибут может принимать одно из двух возможных значений — «чёрный» или «красный».

### Основыне методы

| Метод | Функция |
| --- | --- |
| at  (C++11) | Предоставляет доступ к указанному элементу с проверкой индекса |
| operator[] | Предоставляет доступ к указанному элементу |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11) | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| emplace_hint  (C++11) | Элементы конструкций на месте использования подсказки |
| erase | Удаляет элементы |
| swap | Обменивает содержимое |
| count | Возвращает количество элементов, соответствующих определенному ключу |
| find | находит элемент с конкретным ключом |
| equal_range | возвращает набор элементов для конкретного ключа |
| lower_bound | возвращает итератор на первый элемент не меньше, чем заданное значение |
| upper_bound | возвращает итератор на первый элемент больше, чем определенное значение |
| key_comp | возвращает функцию, сравнивающую ключи |
| value_comp | возвращает функцию, сравнивающую значения |

### Сложности основных алгоритмов

1. Поиск по ключу - O(log(n))
2. Сортировка - O
3. Вставка - O(log(n))
4. Удаление - O(log(n))

### Пример использования



## 3) Класс std::set. Внутренняя реализация set, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::set

## Класс std set

Set — ассоциативный контейнер, который содержит упорядоченный набор уникальных объектов типа Key. Сортировка элементов осуществляется применением функции Compare к ключам множества. Операции поиска, удаления и вставки имеют логарифмическую сложность. Данный тип обычно реализуется как красно-черные деревья.

### Основные методы

| Метод | Функция |
| --- | --- |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11) | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| emplace_hint  (C++11) | Элементы конструкций на месте использования подсказки |
| erase | Удаляет элементы |
| swap | Обменивает содержимое |
| count | Возвращает количество элементов, соответствующих определенному ключу |
| find | находит элемент с конкретным ключом |
| equal_range | возвращает набор элементов для конкретного ключа |
| lower_bound | возвращает итератор на первый элемент не меньше, чем заданное значение |
| upper_bound | возвращает итератор на первый элемент больше, чем определенное значение |
| key_comp | возвращает функцию, сравнивающую ключи |
| value_comp | возвращает функцию, сравнивающую значения |

### Сложности основных алгоритмов

1. Поиск - O(log(n))
2. Вставка - O(log(n))
3. Удаление - O(log(n))

## 4) Класс std::unordered_map. Внутренняя реализация unordered_map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std:: unordered_map

## Класс std unordered map

Unordered map является ассоциативным контейнером, который содержит пары ключ-значение с уникальными ключами. Поиск, вставка и удаление выполняются за константное время.

### Основные методы

| Метод | Функция |
| --- | --- |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| emplace_hint | Элементы конструкций на месте использования подсказки |
| erase | Удаляет элементы |
| swap | Обменивает содержимое |
| at | Предоставляет доступ к указанному элементу с проверкой индекса |
| operator[] | Предоставляет доступ к указанному элементу |
| count | Возвращает количество элементов, соответствующих определенному ключу |
| find | находит элемент с конкретным ключом |
| equal_range | возвращает набор элементов для конкретного ключа |
| begin(int) cbegin(int) | возвращает итератор на начало указанного сегмента |
| end(int) cend(int) | возвращает итератор на конец указанного сегмента |
| bucket_count | Возвращает количество bucket'ов |
| max_bucket_count | Возвращает максимальное количество bucket'ов |
| bucket_size | Возвращает количество элементов в конкретном bucket'е |
| bucket | Возвращает bucket для конкретного ключа |
| load_factor | Возвращает среднее количество элементов на bucket |
| max_load_factor | Управляет максимальным средним количеством элементов на bucket |
| rehash | Резервирует количество bucket'ов, не меньшее запрошенного, соответственно перестраивая хэш-таблицу. |
| reserve | Запасает место для, как минимум, указанного числа элементов. Это восстанавливает хэш-таблицу. |

## 5) Класс std::vector. Внутренняя реализация vector, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::vector. Особенность std::vector<bool>.
  
  Элементы хранятся непрерывно, а значит доступны не только через итераторы, но и через смещения, добавляемые к указателям на элементы (data() или же, для непустых массивов, — &vect[0]). Это означает, что указатель на элемент вектора может передаваться в любую функцию, ожидающую указатель на элемент массива.	(начиная с C++03)
Хранилище вектора обрабатывается автоматически, расширяясь и сужаясь по мере необходимости. Векторы обычно занимают больше места, чем статические массивы, поскольку некоторое количество памяти выделяется про запас на обработку будущего роста. Таким образом, память для вектора требуется выделять не при каждой вставке элемента, а только после исчерпания резервов. Общий объём выделенной памяти можно получить с помощью функции capacity(). Резервная память может быть возвращена системе через вызов shrink_to_fit().

Перераспределения обычно являются дорогостоящими операциями в плане производительности. Функция reserve() может использоваться для предварительного выделения памяти и устранения перераспределений, если заранее известно количество элементов.

### Основные методы

| Метод | Функция |
| --- | --- |
| at | Предоставляет доступ к указанному элементу с проверкой индекса |
| operator[] | Предоставляет доступ к указанному элементу |
| front | Предоставляет доступ к первому элементу |
| back | предоставляет доступ к последнему элементу |
| data  (C++11) | Предоставляет прямой доступ к внутреннему содержимому |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| reserve | Зарезервировать память. |
| capacity | Возвращает количество элементов, которые могут одновременно храниться в выделенной области памяти |
| shrink_to_fit  (C++11) | Уменьшает использование памяти, высвобождая неиспользуемую |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11) | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| erase | Удаляет элементы |
| push_back | добавляет элемент в конец |
| emplace_back  (C++11) | Конструирует элементы "на месте" в конце контейнера |
| pop_back | Удаляет последний элемент |
| resize | Изменяет количество хранимых элементов |
| swap | Обменивает содержимое |

### Сложности основных алгоритмов

1. Произвольный доступ — постоянная O(1)
2. Вставка и удаление элементов в конце — амортизированная постоянная O(1)
3. Вставка и удаление элементов — линейная по расстоянию до конца вектора O(n)

### Особенность std::vector<bool>

Способ, которым std::vector < bool > сделан компактным, определяется реализацией. Одной из потенциальных оптимизаций является сливание векторных элементов таким образом, что каждый элемент занимает один бит, а не байт, как обычный элемент типа bool.

std::vector< bool > ведет себя аналогично std::vector, но для того, чтобы быть компактным, он:
- Не обязательно хранит свои данные в одном непрерывном куске памяти.
- Предоставляет std::vector<bool>::reference как метод доступа к отдельным битам.
- Не использует std::allocator_traits::construct чтобы построить битовые значения.

  
## 6) Парадигмы ООП. Полиморфизм (статический, динамический). Инкапсуляция. Наследование. Примеры.
## 7) Разработка обобщенных типов: шаблоны С++. Инстанцирование. Спецификация шаблонов. Примеры.
## 8) Итераторы: определение, назначение, преимущества. Итераторы прямого доступа, итераторы ввода, итераторы вывода, двунаправленные итераторы, прямой итератор. Примеры.
## 9) Современный С++: auto, decltype, range base loop, nullptr, constexpr, enum class, if constexpr.
## 10) Современный С++: static_assert, initializer_list, default, final, override, using
## 11) Современный С++: std::optional, std::variant, std::any, std::string_view. Примеры использования
## 12) Лямбда-функции, функторы, указатели на функции, std::functional. Примеры использования std::functional. Примеры использования лямбда-функций.
## 13) R-value ссылки. Семантика перемещения. std::move, std::forward. Пример.
  
  Rvalue ссылки - техническое расширение языка C++. Они позволяют компилятору определить, когда необходимо использовать перемещение, вместо копирования. 
  
  Семантика перемещения позволяет компиляторам заменять дорогостоящие операции копирования "дешевыми" операциями перемещения. Семантика также позволяет создавать типы, которые концептуальлно поддерживают только опферации перемещения. 
  
  std::move безусловно приводит аргумент фк ravalue ссылке.
  
  ```cpp
    std::string str = "Salut";
    std::vector<std::string> v;
 
    v.push_back(str);
    std::cout << "After copy, str is " << str << '\n';
 
    v.push_back(std::move(str));
    std::cout << "After move, str is " << str << '\n';
 
    std::cout << "The contents of the vector are { " << std::quoted(v[0])
                                             << ", " << std::quoted(v[1]) << " }\n";
  ```
  
  Функция std::forward применяется при идеальной передаче (perfect forwarding). Идеальная передача позволяет создавать функции-обертки, передающие параметры без каких-либо изменений (lvalue передаются как lvalue, а rvalue – как rvalue).
  
  ```cpp
  void push(T&& value) {
    T* data = new T[length];
    if (length) {
      for (unsigned int i = 0; i < length; ++i) data[i] = forward<T>(ptr[i]);
    }
    delete[] ptr;
    ++length;
    ptr = new T[length];
    for (unsigned int i = 0; i < length - 1; ++i) ptr[i] = forward<T>(data[i]);
    delete[] data;
    ptr[length - 1] = forward<T>(value);
  }
  ```
  
## 14) Обработка ошибок с использованием механизма обработки исключений. RAII. Примеры классов, использующих RAII. Ключевое слово noexcept.
  
  Пример обработки ошибок с использованием механизма обработки исключений:
  ```cpp
  try
{
    // Здесь мы пишем стейтменты, которые будут генерировать следующее исключение
    throw -1; // типичный стейтмент throw
}
 
  catch (int a)
{
    // Обрабатываем исключение типа int
    std::cerr << "We caught an int exception with value" << a << '\n';
}
  ```
  
  Идиома RAII
Resource Acquisition Is Initialization - идиома объектно-ориентированного программирования, смысл которой заключается в том, что получение некоторого ресурса неразрывно совмещается с инициализацией объекта, а освобождение — с уничтожением.
  
  RAII
Другими словами, выделяем память (или любой другой ресурс) в конструкторе некого объекта, а освобождаем - в деструкторе.
  
  Классы использующие RAII: boost::scooped_ptr, std::unique_ptr, std::shared_ptr, std::weak_ptr.

  Noexept - метод с помощью которого программист сообщает компилятору, должна ли функция создавать исключения. 
  
## 15) RAII. «Умные» указатели. std::shared_ptr. Примеры.
  
  RAII см. 14 вопрос

  Указатель std::shared_ptr используется для управления ресурсами путем совместного владения, т.е. объект, на который указывает shared_ptr, унитожится только после того, как не останется ни одного shared_ptr ссылающегося на него.
  
  std::shared_ptr является копируемым и перемещаемым.
  
  Подсчет ссылок в shared_ptr построен с помощью атомарного счетчика, Можно безопасно использовать указатели лна один и тот же объект из разных потоков. 
  
  ``` cpp
  std::shared_ptr ptr(new Image("~/Photo.png"));
  
  std::shared_ptr another_ptr = ptr;
  assert(ptr != nullptr);
  assert(another_ptr != nullptr);
  
  std::yet_another_ptr = std::move(ptr);
  assert(ptr == nullptr);
  assert(yet_another_ptr != nullptr);
  ```

## 16) RAII. «Умные» указатели. std::unique_ptr. Примеры.\
  
  RAII см. 14 вопрос
  
  std::unique_ptr - владеет объектом, на который указывает, т.е. отвечает за уничтожение объекта и освобождение памяти.
  
  std::unique_ptr - является некопируемый, но перемещаемым объектом. При попытке копировать std::unique_ptr получим ошибку компиляции.
  
  По умолчанию, std::unique_ptr имеет тот же размер, что и обычные указатели. Для большинства операций выполняются точно такие же команды. Следовательно std::unique_ptr можно использовать, когда важны расход памяти и времени.
  
  Совместим с stl-контейнером. Поддерживает custom deleater.
  
  ``` cpp
  std::unique_ptr ptr(new Image("~/photo.png"));
  std::unique_ptr amother_ptr = std::move(ptr);
  assert(ptr == nullptr);
  assert(another_ptr != nullptr);
  ```
  ## 17) RAII. «Умные» указатели. std::weak_ptr. Примеры.
  
  RAII см. 14 вопрос
  
  Умный указатель std::weak_ptr был разработан для решения проблемы «циклической зависимости». std::weak_ptr является наблюдателем — он может наблюдать и получать доступ к тому же объекту, на который указывает std::shared_ptr (или другой std::weak_ptr), но не считаться владельцем этого объекта.
  
  ```cpp
  weak_ptr<Parent> parentWeakPtr_ = parentSharedPtr;
  shared_ptr<Parent> tempParentSharedPtr = parentWeakPtr_.lock();
if( !tempParentSharedPtr ) {
  // yes, it may fail if the parent was freed since we stored weak_ptr
} else {
  // do stuff
}
```
  
## 18) Сетевое взаимодействие. Berkley sockets. Основные функции для работы с сокетами
## 19) Сетевое взаимодействие. Сокеты. Библиотека boost asio.
## 20) Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future, функция std::async.
## 21) Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры использования thread_local.
  
  Контекст потоков:
Чтобы операционная система поддерживала многозадачность, каждый выполняемый поток должен обладать своим контекстом исполнения. Этот контекст используется для хранения данных о текущем состоянии потока: значения регистров процессора, указателя на стек данных, указатель на текущую выполняемую команду.
  
  Переключение контекста потоков: 
Обновляется контекст текущего потока. Из имеющихся потоков в ОС выбирается один, который будет исполняться на процессоре. Загружается контекст выбранного потока
 
Создание объекта типа std::thread запускает новый поток.
  
До вызова деструктора объекта типа std::thread необходимо вызвать или метод join(), или метод detach(). Иначе, во время вызова деструктора произойдет вызов std::terminate().
  
## 22) Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры использования std::thread.
## 23) Синхронизация потоков. Состояние гонок. Классы std::mutex, std::lock_guard, std::unique_lock. Функция std::lock. Примеры использования мьютексов.
## 24) Синхронизация потоков. Состояние гонок. Классы std::recursive_mutex, boost::shared_mutex, std::unique_lock. Функция std::lock. Пример использования std::unique_lock
## 25) Класс std::condition_variable. Потокобезопасные структуры данных с блокировками.
## 26) Синхронизация потоков. Пул потоков. Класс std::condition_variable. Примеры работы с std::condition_variable
## 27) Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future, функция std::async
## 28) Атомарные операции. Классы std::atomic, std::atomic_flag. Примеры работы с std::atomic
## 29) Шаблоны проектирования: фабричный метод. Пример реализации «простой фабрики» и «фабричного метода».
  
  Шаблон проектирования - повторяющаяся архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.
  
  Паттерн "Простая фабрика" - это класс, в котором есть один метод с большим условным оператором, выбирающим создаваемый продукт.
  
  ```cpp
  struct Barrack {
  Unit* CreateUnit(UnitID unit_id) {
 
    switch (unit_id) {
      case UnitID::Knight:
        return new Knight();
      case UnitID::Archer:
        return new Archer();
      default:
        return nullptr;
    }
  }
};
  ```
  
  Паттерн "Фабричный метод" - это устройство классов, при котором подклассы могут переопределять тип создаваемого в суперклассе продукта.
  
  ```cpp
  struct Barrack {
  virtual Unit* CreateUnit() = 0;
 
  void Hire(Player& player) {
    auto* unit = CreateUnit();
    player.AddToArmy(unit);
  }
  
  struct KnightBarrack : public Barrack {
  Unit* CreateUnit() override {
    return new Knight();
  }
};
struct ArcherBarrack : public Barrack {
  Unit* CreateUnit() override {
    return new Archer();
  }
};
 
ArcherBarrack archer_barrack;
archer_barrack.Hire(player);
KnightBarrack knight_barrack;
knight_barrack.Hire(player);
};
  
  ```
  
## 30) Шаблоны проектирования: observer. Пример реализации «обозреватель».
  
  Observer - это поведенческий паттерн проектирования, который создает механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.
  
  ```cpp
  struct Publisher {
  struct Observer {
    virtual void OnUpdate() = 0;
  };
  void AddObserver(const Observer& observer);
  void RemoveObserver(const Observer& observer);
  void DoSomething();
 private:
  void Notify();
  std::vector<Observer*> observers_;
};
  -------------------------------------------------
  void Publisher::AddObserver(const Observer& observer) {
  observers_.push_back(&observer);
}
 
void Publisher::RemoveObserver(const Observer& observer) {
  auto it = std::remove(
      observers_.begin(), observers_.end(), &observer);
  observers_.erase(it, observers_.end());
}
 void Publisher::Notify() {
  for (auto* observer : observers_) {
    observer->OnUpdate();
  }
}
 
void Publisher::DoSomething() {
  // Выполнение некоторых действий.
  // Решаем, что необходимо умедомить наблюдателей о событии.
  Notify();
  // Продолжчаем выполнение функции.
} 
 ------------------------------------------------- 
  struct SubscriberOne : public Publisher::Observer {
  void OnUpdate() {
    // Реагирование на уведомление от Publisher'a
  }
};
struct SubscriberTwo : public Publisher::Observer {
  void OnUpdate() {
    // Реагирование на уведомление от Publisher'a
  }
};
  
  Publisher publisher;
SubscriberOne subscriber1;
SubscriberTwo subscriber2;
publisher.AddObserver(subscriber1);
publisher.AddObserver(subscriber2);
publisher.DoSomething();
  ```
  
## 31) Шаблоны проектирования: синглтон. Пример реализации Синглтона.
  
  Singletone - порождающий шаблон проектирования, гарантирующий, что в приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.
  
  ```cpp
  // Singleton.h
class Singleton {
  static Singleton* instance;
  Singleton() {}
  Singleton(const Singleton&) = delete;
  Singleton& operator=(Singleton&) = delete;
public:
 
  static Singleton * getInstance() {
    if (!instance) {
      instance = new Singleton();
    }
    return instance;
  }
};
--------------------------------------------  
  // Singleton.cpp
#include "Singleton.h"
 
Singleton* Singleton::instance = nullptr;
  ```
  
## 32) Асинхронное программирование. Плюсы и минусы. Сопрограммы. Функции обратного вызова.
## 33) Атомарные операции. Классы std::atomic. Структуры данных без блокировок. Реализация lock-free stack
  
  
