# ekzamen-3-sem
## 1) Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента. Реализация функции удаления элемента из двусвязного списка. Основные методы std::list. Пример работы с std::list

Каждый узел двусвязного линейного списка содержит два поля указателей — на следующий и на предыдущий узлы. Указатель на предыдущий узел корня списка и указатель на следующий узел последнего содержат нулевое значение.

Поиск элемента по значению
Сложность O(n). Проходим по всему списку и сравниваем каждый элемент с данным значением.

Вставка элемента
Сложность O(n). Сначала находим нужный элемент, затем создаём новый узел. Затем изменяем указатели.

Удалениие элемента
Сложность O(n). Аналогично вставке.

Сортировка
Для сортировки вставками алгоритмическая сложность будет равна O(n^2), т.к необходми пройти по всему списку и каждый раз вставлять элементы перед требуемым. Соответственно n^2 проходов.

Реализация удаления:

```cpp
struct node {
    void *value;
    node *next;
    node *prev;
};

struct list {
    size_t size;
    node *head;
    node *tail;
};

void* deleteNth(list *_list, size_t index) {
    node *elm = _list->head;
    void *tmp = nullptr;
    size_t i = 0;
    while (elm && i < index) {
        elm = elm->next;
        i++;
    }
    if (elm == nullptr) {
        exit(5);
    }
    if (elm->prev) {
        elm->prev->next = elm->next;
    }
    if (elm->next) {
        elm->next->prev = elm->prev;
    }
    tmp = elm->value;
    if (!elm->prev) {
        _list->head = elm->next;
    }
    if (!elm->next) {
        _list->tail = elm->prev;
    }
    delete elm;
    _list->size--;
    return tmp;
}
```

std::list - двусвязный список.

| Метод | Функция |
| --- | --- |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11)  | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| erase | Удаляет элементы
| push_back | добавляет элемент в конец |
| emplace_back  (C++11) | Конструирует элементы "на месте" в конце контейнера |
| pop_back | Удаляет последний элемент |
| push_front | вставляет элементы в начало списка |
| emplace_front  (C++11) | конструирует элементы "на месте" в начало списка |
| pop_front | удаляет первый элемент |
| resize | Изменяет количество хранимых элементов |
| swap | Обменивает содержимое |
| merge | слияние двух отсортированных списков |
| splice | перемещает элементы из другого list |
| remove / remove_if | удаляет элементы, удовлетворяющие определенным критериям |
| reverse | инвертирует порядок элементов |
| unique | удаляются последовательно повторяющиеся элементы |
| sort | сортирует элементы |

Пример работы с std::list:

```cpp
std::list<int> numbers{1, 2, 4, 5};
if (numbers.empty())
    std::cout << "The list is empty" << std::endl;
else
    std::cout << "The list is not empty" << std::endl;
numbers.push_back(23);  
numbers.push_front(15); 
```

## 2) Класс std::map. Внутренняя реализация map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::map

std::map — отсортированный ассоциативный контейнер, который содержит пары ключ-значение с неповторяющимися ключами. Порядок ключей задаётся функцией сравнения Compare. Данный тип, как правило, реализуется как красно-чёрное дерево.

Красно-чёрное дерево — один из видов из самобалансирующихся двоичных деревьев поиска, гарантирующих логарифмический рост высоты дерева от числа узлов и позволяющее быстро выполнять основные операции дерева поиска: добавление, удаление и поиск узла. Сбалансированность достигается за счёт введения дополнительного атрибута узла дерева — «цвета». Этот атрибут может принимать одно из двух возможных значений — «чёрный» или «красный».

### Основыне методы

| Метод | Функция |
| --- | --- |
| at  (C++11) | Предоставляет доступ к указанному элементу с проверкой индекса |
| operator[] | Предоставляет доступ к указанному элементу |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11) | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| emplace_hint  (C++11) | Элементы конструкций на месте использования подсказки |
| erase | Удаляет элементы |
| swap | Обменивает содержимое |
| count | Возвращает количество элементов, соответствующих определенному ключу |
| find | находит элемент с конкретным ключом |
| equal_range | возвращает набор элементов для конкретного ключа |
| lower_bound | возвращает итератор на первый элемент не меньше, чем заданное значение |
| upper_bound | возвращает итератор на первый элемент больше, чем определенное значение |
| key_comp | возвращает функцию, сравнивающую ключи |
| value_comp | возвращает функцию, сравнивающую значения |

### Сложности основных алгоритмов

1. Поиск по ключу - O(log(n))
2. Сортировка - O
3. Вставка - O(log(n))
4. Удаление - O(log(n))

### Пример использования

```cpp
 int main()
{
    std::map<std::string, int> m { {"CPU", 10}, {"GPU", 15}, {"RAM", 20}, };
 
    m["CPU"] = 25;  
    m["SSD"] = 30;  
 
    for (const auto& [key, value] : m) {
        std::cout << key << " = " << value << "; ";
    }
}
```

## 3) Класс std::set. Внутренняя реализация set, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::set

std::set — ассоциативный контейнер, который содержит упорядоченный набор уникальных объектов типа Key. Сортировка элементов осуществляется применением функции Compare к ключам множества. Данный тип обычно реализуется как красно-черные деревья.

### Основные методы

| Метод | Функция |
| --- | --- |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11) | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| emplace_hint  (C++11) | Элементы конструкций на месте использования подсказки |
| erase | Удаляет элементы |
| swap | Обменивает содержимое |
| count | Возвращает количество элементов, соответствующих определенному ключу |
| find | находит элемент с конкретным ключом |
| equal_range | возвращает набор элементов для конкретного ключа |
| lower_bound | возвращает итератор на первый элемент не меньше, чем заданное значение |
| upper_bound | возвращает итератор на первый элемент больше, чем определенное значение |
| key_comp | возвращает функцию, сравнивающую ключи |
| value_comp | возвращает функцию, сравнивающую значения |

### Сложности основных алгоритмов

1. Поиск - O(log(n))
2. Вставка - O(log(n))
3. Удаление - O(log(n))

### Пример работы с std::set:
```cpp
int main()
{
  std::set<std::string> a;
  a.insert("cat");
  a.insert("dog");
  a.insert("horse");
  for(auto& str: a) std::cout << str << ' ';
}
```

## 4) Класс std::unordered_map. Внутренняя реализация unordered_map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::unordered_map

Unordered map является ассоциативным контейнером, который содержит пары ключ-значение с уникальными ключами. Поиск, вставка и удаление выполняются за константное время.

### Основные методы

| Метод | Функция |
| --- | --- |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| emplace_hint | Элементы конструкций на месте использования подсказки |
| erase | Удаляет элементы |
| swap | Обменивает содержимое |
| at | Предоставляет доступ к указанному элементу с проверкой индекса |
| operator[] | Предоставляет доступ к указанному элементу |
| count | Возвращает количество элементов, соответствующих определенному ключу |
| find | находит элемент с конкретным ключом |
| equal_range | возвращает набор элементов для конкретного ключа |
| begin(int) cbegin(int) | возвращает итератор на начало указанного сегмента |
| end(int) cend(int) | возвращает итератор на конец указанного сегмента |
| bucket_count | Возвращает количество bucket'ов |
| max_bucket_count | Возвращает максимальное количество bucket'ов |
| bucket_size | Возвращает количество элементов в конкретном bucket'е |
| bucket | Возвращает bucket для конкретного ключа |
| load_factor | Возвращает среднее количество элементов на bucket |
| max_load_factor | Управляет максимальным средним количеством элементов на bucket |
| rehash | Резервирует количество bucket'ов, не меньшее запрошенного, соответственно перестраивая хэш-таблицу. |
| reserve | Запасает место для, как минимум, указанного числа элементов. Это восстанавливает хэш-таблицу. |

### Пример работы с std::unordered_map:
```cpp
int main()
{
    // Create an unordered_map of three strings (that map to strings)
    std::unordered_map<std::string, std::string> u = {
        {"RED","#FF0000"},
        {"GREEN","#00FF00"},
        {"BLUE","#0000FF"}
    };
 
    std::cout << "Iterate and print keys and values of unordered_map, being explicit with\n"
                 "the type of the iterator, n:\n";
    for( const std::pair<std::string, std::string>& n : u ) {
        std::cout << "Key:[" << n.first << "] Value:[" << n.second << "]\n";
    }
}
```

## 5) Класс std::vector. Внутренняя реализация vector, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::vector. Особенность std::vector<bool>.
  
  Элементы хранятся непрерывно, а значит доступны не только через итераторы, но и через смещения, добавляемые к указателям на элементы. Это означает, что указатель на элемент вектора может передаваться в любую функцию, ожидающую указатель на элемент массива.
    
Хранилище вектора обрабатывается автоматически, расширяясь и сужаясь по мере необходимости. Векторы обычно занимают больше места, чем статические массивы, поскольку некоторое количество памяти выделяется про запас на обработку будущего роста. Память для вектора требуется выделять не при каждой вставке элемента, а только после исчерпания резервов. Общий объём выделенной памяти можно получить с помощью функции capacity(). Резервная память может быть возвращена системе через вызов shrink_to_fit(). Перераспределения обычно являются дорогостоящими операциями в плане производительности. Функция reserve() может использоваться для предварительного выделения памяти и устранения перераспределений, если заранее известно количество элементов.

### Основные методы

| Метод | Функция |
| --- | --- |
| at | Предоставляет доступ к указанному элементу с проверкой индекса |
| operator[] | Предоставляет доступ к указанному элементу |
| front | Предоставляет доступ к первому элементу |
| back | предоставляет доступ к последнему элементу |
| data  (C++11) | Предоставляет прямой доступ к внутреннему содержимому |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| reserve | Зарезервировать память. |
| capacity | Возвращает количество элементов, которые могут одновременно храниться в выделенной области памяти |
| shrink_to_fit  (C++11) | Уменьшает использование памяти, высвобождая неиспользуемую |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11) | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| erase | Удаляет элементы |
| push_back | добавляет элемент в конец |
| emplace_back  (C++11) | Конструирует элементы "на месте" в конце контейнера |
| pop_back | Удаляет последний элемент |
| resize | Изменяет количество хранимых элементов |
| swap | Обменивает содержимое |

### Сложности основных алгоритмов

1. Произвольный доступ — постоянная O(1)
2. Вставка и удаление элементов в конце — амортизированная постоянная O(1)
3. Вставка и удаление элементов — линейная по расстоянию до конца вектора O(n)
    
    Пример работы с std::vector:
    
    ```cpp
    int main()
{
    std::vector<int> v = { 7, 5, 16, 8 };
 
    v.push_back(25);
    v.push_back(13);

    for (int n : v) {
        std::cout << n << ", ";
    }
}
    ```

### Особенность std::vector<bool>

Способ, которым std::vector <bool> сделан компактным, определяется реализацией. Одной из потенциальных оптимизаций является сливание векторных элементов таким образом, что каждый элемент занимает один бит, а не байт, как обычный элемент типа bool.

std::vector< bool > ведет себя аналогично std::vector, но для того, чтобы быть компактным, он:
- Не обязательно хранит свои данные в одном непрерывном куске памяти.
- Предоставляет std::vector<bool>::reference как метод доступа к отдельным битам.
- Не использует std::allocator_traits::construct чтобы построить битовые значения.
  
## 6) Парадигмы ООП. Полиморфизм (статический, динамический). Инкапсуляция. Наследование. Примеры.

 Инкапсуляция - объединение кода и данных таким образом, чтобы защищать данные от непреднамеренного использования и внешнего вмешательства. Основные типы доступа: private, protected, public.

  Наследование - приобретение одним объектом свойств другого. Объект может унаследовать характерные черты одного объекта и внести в них изменения, характерные только для него.

Полиморфизм - использование одно и того же имени для решения схожих, но технически разных задач. Целью полиморфизма является использование одного имени для задания общих для класса действий.

Статический полиморфизм реализуется с помощью шаблонов классов. Класс создаётся во время компиляции из шаблона (статическое связывание)

Пример:
```C++
template <typename T>
class Comparison {
public:
    T max(T a, T b) {
        return (a > b) ? a : b;
    }
    T min(T a, T b) {
        return (a < b) ? a : b;
    }
};
```

Диинамический полиморфизм реализуется с помощью перезагрузки функций и абстрактного базового класса. Динамическое связывание происходит во время исполнения программы.

Пример:
```C++
class Comparison {
public:
    int max(int a, int b);
    double max(double a, double b);
};
```
    
## 7) Разработка обобщенных типов: шаблоны С++. Инстанцирование. Спецификация шаблонов. Примеры.
                      
Механизм шаблонов в языке С++ позволяет решать проблему унификации алгоритма для различных типов.

Пример шаблонной функции:
```C++
template<class T>
T _min(T a, T b){
    if( a < b){
        return a;
    }
    return b;
}
```

### Инстанциирование

Шаблон класса сам по себе не является ни типом, ни объектом, ни любой другой сущностью. Из исходного файла, содержащего только определения шаблонов, не генерируется никакого кода. Чтобы компилятор сгенерировал код, данный шаблон должен быть инстанцирован, для чего из шаблона должен быть создан конкретный класс с набором аргументов (или функция для шаблона функции).

Явное определение инстанцирования осуществляет непосредственное инстанцирование класса, структуры или объединения. Такое определение может быть сделано в любом месте программы после определения шаблона, а для заданного списка аргументов, может быть указано только один раз во всей программе.

Пример:
```C++
namespace N
{
  template<class T>
  class Y // определение шаблона
  {
    void mf() { }
  };
}
    
// template class Y<int>; 	  // ошибка: шаблон класса Y не видим в глобальном пространстве имён
using N::Y;
// template class Y<int>; 	  // ошибка: явное инстанцирование вне пространства имён шаблона
template class N::Y<char*>;       // OK: явное инстанцирование
template void N::Y<double>::mf(); // OK: явное инстанцирование
```

Когда код ссылается на шаблон в контексте, который требует полностью определённого типа, или когда полнота типа влияет на код, и этoт конкретный тип не был явно инстанцирован, то происходит неявное инстанцирование. Например, когда создаётся объект этoго типа, но не указатель на этoт тип. Это применимо и к членам шаблона класса - если данный член не использован в программе, то он не инстанцируется и не требует определения.

Пример:
```C++
template<class T>
struct Z // определение шаблона
{
    void f() {}
    void g(); // нет определения
};
template struct Z<double>; // явное инстанцирование Z<double>
Z<int> a; 		   // неявное инстанцирование Z<int>
Z<char>* p; 		   // здесь ничего не инстанцируется
p->f(); 		   // здесь происходит неявное инстанцирование Z<char> и Z<char>::f().
```

Спецификация шаблона - написание реализации для конкретного типа. Если эта версия шаблона функции в коде не используется, то она не будет включена в бинарный код.

```C++
template<>
std::string _min(std::string a, std::string b){
    if(a.size() < b.size()){
        return a;
    }
    return b;
}
```
                      
## 8) Итераторы: определение, назначение, преимущества. Итераторы прямого доступа, итераторы ввода, итераторы вывода, двунаправленные итераторы, прямой итератор. Примеры.

Итераторе - указатель на определённый элемент контейнерного класса с дополнительным набором перегруженных операторов для выполнения чётко определённых функций:

-   Оператор * возвращает элемент, на который в данный момент указывает итератор.

-   Оператор ++ перемещает итератор к следующему элементу контейнера. Большинство итераторов также предоставляют оператор −− для перехода к предыдущему элементу.

-   Операторы == и != используются для определения того, указывают ли два итератора на один и тот же элемент или нет. Для сравнения значений, на которые указывают два итератора, нужно сначала разыменовать эти итераторы, а затем использовать оператор == или !=.

-   Оператор = присваивает итератору новую позицию (обычно начало или конец элементов контейнера). Чтобы присвоить значение элемента, на который указывает итератор, другому объекту, нужно сначала разыменовать итератор, а затем использовать оператор =.

Каждый контейнерный класс имеет 4 основных метода для работы с оператором =:

-   begin() возвращает итератор, представляющий начало элементов контейнера.

-   end() возвращает итератор, представляющий элемент, который находится после последнего элемента в контейнере.

-   cbegin() возвращает константный (только для чтения) итератор, представляющий начало элементов контейнера.

-   cend() возвращает константный (только для чтения) итератор, представляющий элемент, который находится после последнего элемента в контейнере.

### Преимущества

В процедурных языках программирования широко используется индексация, основанная на счётчике цикла, для перебора всех элементов последовательности (например, массива). Хотя индексация может использоваться совместно с некоторыми объектно-ориентированными контейнерами, использование итераторов даёт свои преимущества:

Индексация не подходит для некоторых структур данных, в частности, для структур данных с медленным произвольным доступом или вообще без поддержки такового (например, список или дерево).
Итераторы предоставляют возможность последовательного перебора любых структур данных, поэтому делают код более читаемым, удобным для повторного использования и менее чувствительным к изменениям структур данных.

Итераторы могут предоставлять дополнительные возможности при навигации по элементам. Например, проверку отсутствия пропусков элементов или защиту от повторного перебора одного и того же элемента.
Некоторые контейнеры могут предоставлять возможность модифицировать свои объекты без влияния на сам итератор. Например, после того, как итератор уже «прошёл» первый элемент, можно вставить дополнительные элементы в начало контейнера без каких-либо нежелательных последствий. При использовании индексации это проблематично из-за смены номеров индексов.

### Типы итераторов

##### Итератор ввода

```Input iterator``` предназначен только для однократного чтения (ввода) последовательности значений.
```C++
Value value = *it++; // прочитать следующее значение, it - итератор
```
Итератор можно передвигать на одну позицию вперед (инкремент) и разыменовывать (операции * и ->), получая доступ к текущему значению. Итераторы можно сравнивать между собой на равенство и неравенство.

##### Итератор вывода

```Output iterator``` предназначен только для однократной записи (вывода) последовательности. В остальном аналогичен итератору ввода.
```C++
*it++ = value;
```
##### Однонаправленный итератор

```Forward iterator``` является расширением концепции “итератор ввода”, т.е. предоставляет возможности итератора ввода (и, возможно, но не гарантированно, итератора вывода). Кроме того, однонаправленный итератор допускает многократное чтение и запись линейной последовательности, по которой можно двигаться только в одну сторону (как по односвязному списку — “вперёд” с помощью операции ++).

##### Двунаправленный итератор

```bidirectional iterator``` является расширением концепции “однонаправленный итератор”. Двунаправленный итератор допускает движение в двух направлениях: вперед (с помощью ++) и назад (с помощью операции --).

##### Итератор произвольного доступа

```random access iterator``` является расширением концепции “двунаправленный итератор” и наиболее похож по своему поведению на обычный указатель на элемент массива (который является частным случаем итератора произвольного доступа).

Итератор произвольного доступа допускает адресацию по индексу (оператор []), сдвиг в обе стороны на некоторое количество позиций (добавление и вычитание целого числа), вычисление расстояния с помощью вычитания и сравнение на “меньше” и “больше” (согласованное с расстоянием, которое имеет знак).
                    
## 9) Современный С++: auto, decltype, range base loop, nullptr, constexpr, enum class, if constexpr.
    
    ### auto

До С++11, ключевое слово auto использовалось как спецификатор хранения переменной (как, например, register, static, extern). В С++11 auto позволяет не указывать тип переменной явно, говоря компилятору, чтобы он сам определил фактический тип переменной, на основе типа инициализируемого значения.
    
    ```cpp
    for (auto i : vec) {
        cout << i << endl;
    }
    ```

### decltype

```Decltype``` позволяет статически определить тип по типу другой переменной.

```C++
int x = 5;
double y = 5.1;

decltype(x) foo;    // int
decltype(y) bar;    // double
decltype(x+y) baz;  // double
```

### Range based loop

```Range-Based for``` — это цикл по контейнеру.

```C++
for (int& x : foo)
    x *= 2;

for (const int& x : foo)
    std::cout << x << std::endl;
```

### nullptr

Раньше, для обнуления указателей использовался макрос NULL, являющийся нулем — целым типом, что, естественно, вызывало проблемы (например, при перегрузке функций). Ключевое слово nullptr имеет свой собственный тип std::nullptr_t, что избавляет нас от бывших проблем. Существуют неявные преобразования nullptr к нулевому указателю любого типа и к bool (как false), но преобразования к целочисленных типам нет.

```C++
void foo(int* p) {}

void bar(std::shared_ptr<int> p) {}

int* p1 = NULL;
int* p2 = nullptr;   

if(p1 == p2)
{}

foo(nullptr);
bar(nullptr);

bool f = nullptr;
int i = nullptr; // ошибка: для преобразования в int надо использовать reinterpret_cast
```

### Constexpr

С помощью него можно создавать переменные, функции и даже объекты, которые будут рассчитаны на этапе компиляции. Это удобно, ведь раньше для таких целей приходилось использовать шаблоны.

##### constexpr-функция

Ключевое слово constexpr, добавленное в C++11, перед функцией означает, что если значения параметров возможно посчитать на этапе компиляции, то возвращаемое значение также должно посчитаться на этапе компиляции. Если значение хотя бы одного параметра будет неизвестно на этапе компиляции, то функция будет запущена в runtime (а не будет выведена ошибка компиляции).

##### constexpr-переменная

Ключевое слово в данном случае означает создание константы. Причем expression должно быть известно на этапе компиляции.

```C++
int sum (int a, int b)
{
	return a + b;
}

constexpr int new_sum (int a, int b)
{
	return a + b;
}

void func()
{
	constexpr int a1 = new_sum (5, 12); // ОК: constexpr-переменная
	constexpr int a2 = sum (5, 12); // ошибка: функция sum не является constexp-выражением
	int a3 = new_sum (5, 12); // ОК: функция будет вызвана на этапе компиляции
	int a4 = sum (5, 12); // ОК
}
```

### enum-class

Перечисление представляет собой особый тип, значение которого ограничивается одной из нескольких явно именованных констант ("счетчики"). Значения констант - это значения целого типа, известного также как базовый тип перечисления.

```C++
enum color {
    red,            //присваевается 0
    yellow,         //присваевается 1
    green = 20,     //присваевается 20
    blue            //присваевается 21
};  
```
    
    ### if constexpr
    
    if constexpr вычисляется во время компиляции, а if - нет. Это означает, что ветви могут быть отклонены во время компиляции и, следовательно, никогда не будут скомпилированы.
    
    ```cpp
    template <typename T>
void mixStaticWithDynamicIncorrect(T val)
{
    if constexpr(std::is_integral<T>::value)
        std::cout << "Integral passed.";
    else if(val == std::string{"clone"})
        std::cout << "Known string passed.";
    else if constexpr(std::is_same_v<T, std::string>)
        std::cout << "General string passed.";
    else
        std::cout << "Unknown type variable passed.";
    std::cout << "\n";
}
    ```
    
## 10) Современный С++: static_assert, initializer_list, default, final, override, using
    
    ### static_assert

В C++11 добавили ещё один тип ```assert```-а — ```static_assert```. В отличие от assert, который выполняется во время выполнения, static_assert выполняется во время компиляции, вызывая ошибку компилятора, если условие не является истинным. Если условие ложное, то выводится диагностическое сообщение.

```C++
static_assert(sizeof(long) == 8, "long must be 8 bytes");
static_assert(sizeof(int) == 4, "int must be 4 bytes");
```

    ###  Конструкторы принимающие initializer_list

Конструкторы, походящие на конструкторы контейнеры, принимающие значения в угловых скобках. Реализованны данные конструкторы посредством класса std::initializer_list, что позволяет упростить множественное присваивание.
    
     ```cpp
    template <class T>
    struct S {
        std::vector<T> v;
        S(std::initializer_list<T> l) : v(l) {
            std::cout << "constructed with a " << l.size() << "-element list\n";
        }
    };
 
    int main()
    {
        S<int> s = {1, 2, 3, 4, 5}; // copy list-initialization
    }
    ```

    ### default

Суть его заключается в том, что пользователь может указать компилятору реализовать ту или иную функцию-член класса по-умолчанию.

```cpp
class Foo
{
public:
    Foo() = default;
    Foo(int x) {/* ... */}
};
```
    
    ### Final

Ключевое слово позволяет запретить переопределение виртуального метода в дочернем классе. Также  ```final``` может запретить использование класса как базового в дальнейшем

Пример:
```C++
struct Base
{
    virtual void foo();
};

struct A : Base
{
    void foo() final; // Base::foo is overridden and A::foo is the final override
    void bar() final; // Error: non-virtual function cannot be overridden or be final
};

struct B final : A // struct B is final
{
    void foo() override; // Error: foo cannot be overridden as it's final in A
};

struct C : B // Error: B is final
{
};
```

    ### Override

Ключевое слово ```override``` следует после объявления метода и означает, что данный метод является виртуальным и переобределяет метод базового класса. Если такого метода в базовом классе нет, компилятор сообщает об этом.

Пример для ```virtual``` и ```override```:
```C++
class figure
{
protected:
  double x, y;
public:
  figure(double a = 0, double b = 0) { x = a; y = b; }
  virtual double area() {return(0);}
};
class rectangle : public figure
{
public:
  rectangle(double a = 0, double b = 0) : figure(a, b) {};
  double area() override {return(x*y);}
};
class circle : public figure
{
public:
  circle(double a = 0) : figure(a, 0) {};
  double area() override {return(3.14*x*x);}
};
```
    
  ### using

С появлением шаблонов в C++, добавление синонимов стало достаточно трудным с использованием ```typedef```, соответсвенно для решения этой проблемы, а также упрощения кода в стандарт был добавлена using.  
    
    ```cpp
    using std::string
    ```
    
## 11) Современный С++: std::optional, std::variant, std::any, std::string_view. Примеры использования
	
	### optional
	
	Класс, который хранит определнное значение и сообщает о том, инициализированно оно или нет. Классическое использование - в функции, которая может и не вернуть значение.
	
	```cpp
	std::optional<std::string> create(bool b) {
	    if (b) return "Godzilla";
	    return {};
	}

	int main()
	{
		std::cout << "create(false) returned " << create(false).value_or("empty") << '\n';
	}
	```

### variant

Шаблон класса, который в качестве шаблонных параметров принимает типы, которые он может содержать. Далее используя функцию std::visit можно узнать хранимый тип

```C++
variant<string, int, bool> mySetting = string("Hello!"); // или
mySetting = 42; // или
mySetting = false;
```
### any

Тут хранится что угодно, что потом можно достать

```C++
std::any a = 1;
    std::cout << a.type().name() << ": " << std::any_cast<int>(a) << '\n';

a = 1;
int* i = std::any_cast<int>(&a);
std::cout << *i << "\n";    
```

### string_view

Позволяет лишить права владения определенной строкой, оставив право просмотра

```C++
void get_vendor_from_id(std::string_view id) { // не аллоцирует память, работает с `const char*`, `char*`, `const std::string&` и т.д.
    std::cout <<
        id.substr(0, id.find_last_of(':')); // не аллоцирует память для подстрок
}
```

	
## 12) Лямбда-функции, функторы, указатели на функции, std::functional. Примеры использования std::functional. Примеры использования лямбда-функций.
	
	Лямбда-функция является удобным способом определения объекта анонимной функции прямо в расположении, где оно вызывается или передается в качестве аргумента функции. 

	Функтор - функциональный объект. Для определения функтора достаточно описать класс, в котором переопределен оператор (). Особо широкое применение функторы приобрели в алгоритмах STL, рассмотренных ранее, когда они передаются в вызов в качестве параметра, вместо функции, определяющей действие или предикат алгоритма.
	
	В языке программирования C функция тоже имеет адрес и может иметь указатель. Указатель на функцию представляет собой выражение или переменную, которые используются для представления адреса функции. Указатель на функцию содержит адрес первого байта в памяти, по которому располагается выполняемый код функции.

	Объекты класса std::function могут хранить, копировать и вызывать произвольные вызываемые объекты — функции, лямбда-выражения, выражения связывания и другие функциональные объекты.
	
	```cpp
	int half(int x) {return x/2;}

	struct third_t {
	  int operator()(int x) {return x/3;}
	};
	
	struct MyValue {
	  int value;
	  int fifth() {return value/5;}
	};

	int main () {
	  std::function<int(int)> fn1 = half;                    // function
	  std::function<int(int)> fn2 = &half;                   // function pointer
	  std::function<int(int)> fn3 = third_t();               // function object
	  std::function<int(int)> fn4 = [](int x){return x/4;};  // lambda expression
	  std::function<int(int)> fn5 = std::negate<int>();      // standard function object

	  std::cout << "fn1(60): " << fn1(60) << '\n';
	  std::cout << "fn2(60): " << fn2(60) << '\n';
	  std::cout << "fn3(60): " << fn3(60) << '\n';
	  std::cout << "fn4(60): " << fn4(60) << '\n';
	  std::cout << "fn5(60): " << fn5(60) << '\n';

	  // stuff with members:
	  std::function<int(MyValue&)> value = &MyValue::value;  // pointer to data member
	  std::function<int(MyValue&)> fifth = &MyValue::fifth;  // pointer to member function

	  MyValue sixty {60};

	  std::cout << "value(sixty): " << value(sixty) << '\n';
	  std::cout << "fifth(sixty): " << fifth(sixty) << '\n';

	  return 0;
	}
	```
	
## 13) R-value ссылки. Семантика перемещения. std::move, std::forward. Пример.
  
  Rvalue ссылки - техническое расширение языка C++. Они позволяют компилятору определить, когда необходимо использовать перемещение, вместо копирования. 
  
  Семантика перемещения позволяет компиляторам заменять дорогостоящие операции копирования "дешевыми" операциями перемещения. Семантика также позволяет создавать типы, которые концептуальлно поддерживают только опферации перемещения. 
  
  std::move безусловно приводит аргумент фк ravalue ссылке.
  
  ```cpp
    std::string str = "Salut";
    std::vector<std::string> v;
 
    v.push_back(str);
    std::cout << "After copy, str is " << str << '\n';
 
    v.push_back(std::move(str));
    std::cout << "After move, str is " << str << '\n';
 
    std::cout << "The contents of the vector are { " << std::quoted(v[0])
                                             << ", " << std::quoted(v[1]) << " }\n";
  ```
  
  Функция std::forward применяется при идеальной передаче (perfect forwarding). Идеальная передача позволяет создавать функции-обертки, передающие параметры без каких-либо изменений (lvalue передаются как lvalue, а rvalue – как rvalue).
  
  ```cpp
  void push(T&& value) {
    T* data = new T[length];
    if (length) {
      for (unsigned int i = 0; i < length; ++i) data[i] = forward<T>(ptr[i]);
    }
    delete[] ptr;
    ++length;
    ptr = new T[length];
    for (unsigned int i = 0; i < length - 1; ++i) ptr[i] = forward<T>(data[i]);
    delete[] data;
    ptr[length - 1] = forward<T>(value);
  }
  ```
  
## 14) Обработка ошибок с использованием механизма обработки исключений. RAII. Примеры классов, использующих RAII. Ключевое слово noexcept.
  
  Пример обработки ошибок с использованием механизма обработки исключений:
  ```cpp
  try
{
    // Здесь мы пишем стейтменты, которые будут генерировать следующее исключение
    throw -1; // типичный стейтмент throw
}
 
  catch (int a)
{
    // Обрабатываем исключение типа int
    std::cerr << "We caught an int exception with value" << a << '\n';
}
  ```
  
  Идиома RAII
Resource Acquisition Is Initialization - идиома объектно-ориентированного программирования, смысл которой заключается в том, что получение некоторого ресурса неразрывно совмещается с инициализацией объекта, а освобождение — с уничтожением.
  
  RAII
Другими словами, выделяем память (или любой другой ресурс) в конструкторе некого объекта, а освобождаем - в деструкторе.
  
  Классы использующие RAII: boost::scooped_ptr, std::unique_ptr, std::shared_ptr, std::weak_ptr.

  Noexept - метод с помощью которого программист сообщает компилятору, должна ли функция создавать исключения. 
  
## 15) RAII. «Умные» указатели. std::shared_ptr. Примеры.
  
  RAII см. 14 вопрос

  Указатель std::shared_ptr используется для управления ресурсами путем совместного владения, т.е. объект, на который указывает shared_ptr, унитожится только после того, как не останется ни одного shared_ptr ссылающегося на него.
  
  std::shared_ptr является копируемым и перемещаемым.
  
  Подсчет ссылок в shared_ptr построен с помощью атомарного счетчика, Можно безопасно использовать указатели лна один и тот же объект из разных потоков. 
  
  ``` cpp
  std::shared_ptr ptr(new Image("~/Photo.png"));
  
  std::shared_ptr another_ptr = ptr;
  assert(ptr != nullptr);
  assert(another_ptr != nullptr);
  
  std::yet_another_ptr = std::move(ptr);
  assert(ptr == nullptr);
  assert(yet_another_ptr != nullptr);
  ```

## 16) RAII. «Умные» указатели. std::unique_ptr. Примеры.\
  
  RAII см. 14 вопрос
  
  std::unique_ptr - владеет объектом, на который указывает, т.е. отвечает за уничтожение объекта и освобождение памяти.
  
  std::unique_ptr - является некопируемый, но перемещаемым объектом. При попытке копировать std::unique_ptr получим ошибку компиляции.
  
  По умолчанию, std::unique_ptr имеет тот же размер, что и обычные указатели. Для большинства операций выполняются точно такие же команды. Следовательно std::unique_ptr можно использовать, когда важны расход памяти и времени.
  
  Совместим с stl-контейнером. Поддерживает custom deleater.
  
  ``` cpp
  std::unique_ptr ptr(new Image("~/photo.png"));
  std::unique_ptr amother_ptr = std::move(ptr);
  assert(ptr == nullptr);
  assert(another_ptr != nullptr);
  ```
  ## 17) RAII. «Умные» указатели. std::weak_ptr. Примеры.
  
  RAII см. 14 вопрос
  
  Умный указатель std::weak_ptr был разработан для решения проблемы «циклической зависимости». std::weak_ptr является наблюдателем — он может наблюдать и получать доступ к тому же объекту, на который указывает std::shared_ptr (или другой std::weak_ptr), но не считаться владельцем этого объекта.
  
  ```cpp
  weak_ptr<Parent> parentWeakPtr_ = parentSharedPtr;
  shared_ptr<Parent> tempParentSharedPtr = parentWeakPtr_.lock();
if( !tempParentSharedPtr ) {
  // yes, it may fail if the parent was freed since we stored weak_ptr
} else {
  // do stuff
}
```
  
## 18) Сетевое взаимодействие. Berkley sockets. Основные функции для работы с сокетами
	
	Взаимодействие в сети рассматривается на основе понятия сокетов, которые позволяют приложениям рассматривать сетевые подключения как файлы, и программа может читать из сокета или писать в сокет, как она делает это с файлом. Существуют два механизма, предназначенных для сетевого взаимодействия программ, - это сокеты датаграмм, которые используют
пользовательский датаграммный протокол (User Datagram Protocol)
(UDP) без установления соединения, и сокеты, используюющие Протокол управления передачей / Межсетевой протокол (Transmission Control Protocol/Internet Protocol) (TCP/IP), устанавливающий соединение.

Для работы с сетью традиционно используются сокеты.
Сокет – это абстракция, которая позволяет работать с сетевыми ресурсами, как с файлами. Мы можем писать и читать данные из сокета почти так же, как из обычного файла.

Функция socket - создает новый сокет с заданными параметрами.
```cpp
int socket(int domain, int type, int protocol);
 
int sock_udp = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
int sock_tcp = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
```

Функция bind - связывает сокет с конкретным адресом сетевого интерфейса.
```cpp
int bind(int sockfd,
         const struct sockaddr *addr,
         socklen_t addrlen);
```
Где `sockaddr` - семейство структур, описывающих адреса (`sockaddr_in` - для сетевого взаимодействияб `sockaddr_un` для межпроцессорного):
Структура `sockaddr_in`:
```cpp
struct sockaddr_in {
    short            sin_family;   // e.g. AF_INET
    unsigned short   sin_port;     // e.g. htons(3490)
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // zero this if you want to
};

struct in_addr {
    unsigned long s_addr;  // load with inet_aton()
};
```

Функция listen - переводит сокет в пассивный режим.
```cpp
int listen(int sockfd, int backlog);
```
Функция listen принимает дескриптор слушающего сокета и размер очереди запросов. Когда клиент пытается соединиться с сервером, его запрос ставится в очередь, так как сервер может быть занят обработкой других запросов. Если очередь заполнена, все последующие запросы будут игнорироваться.

Функция accept ожидает клиентские соединения.
```cpp
int accept(int sockfd,
           struct sockaddr *addr,
           socklen_t *addrlen);

```
В качестве аргумента функции передается дескриптор слушающего сокета.
При успешной установке соединения, для него создается новый сокет. Функция accept возвращает дескриптор этого сокета.
Если произошла ошибка соединения, то возвращается значение INVALID_SOCKET.

В структуру, на которую ссылается addr, записывается адрес сокета клиента, который установил соединение с сервером.
В переменную, адресуемую указателем addrlen, записывается размер структуры.
	
## 19) Сетевое взаимодействие. Сокеты. Библиотека boost asio.
	
	Взаимодействие в сети рассматривается на основе понятия сокетов, которые позволяют приложениям рассматривать сетевые подключения как файлы, и программа может читать из сокета или писать в сокет, как она делает это с файлом. Существуют два механизма, предназначенных для сетевого взаи-
модействия программ, - это сокеты датаграмм, которые используют
пользовательский датаграммный протокол (User Datagram Protocol)
(UDP) без установления соединения, и сокеты, используюющие Протокол управления передачей / Межсетевой протокол (Transmission Control Protocol/Internet Protocol) (TCP/IP), устанавливающий соединение.

Boost.Asio - кросс-платформенная С++ библиотека для программирования сетевых приложений и других низкоуровневых программ ввода/вывода.

Example:
```cpp
// Initialization
boost::system::error_code error;

boost::asio::io_service ioService{};
boost::asio::ip::tcp::socket socket{ioService, error};

...
...

// Binding to port
boost::asio::ip::tcp::endpoint endPoint{boost::asio::ip::v_4(), port};

socket.bind(endPoint, error);

...
...

// Connecting to server
socket.connect(someEndPoint, error);

...
...

// Read-write
std::string request;
request.resize(SOCKET_INPUT_BUFFER_SIZE);

socket.read_some(boost::asio::buffer(request), error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while reading from socket : " << error;
  return error;
}

std::string response = HandleRequest(request, error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while handling request : " << error;
  return error;
}

socket.write_some(boost::asio::buffer(response), error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while writing to socket : " << error;
  return error;
}
```
	
## 20) Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future, функция std::async.
	
	Состояние гонок - ошибка проектирования многпоточной системы, когда работа приложения зависит от того, в каком порядке выполняются части кода. Состояние гонки возникает, кода несколько поток пытаются получить доступ к данным, причем хотя бы один поток уже выполняет запись. Для предотвращения данной ошибки применяются приемы синхронизации структур данных.

std::async позволяет выполнить функцию асинхронно и вернуть результат как std::future, стоит отметить, что функция может быть выполнена и синхронно.

Шаблонный класс std::future обеспечивает механизм доступа к результатам асинхронных операций:

Асинхронные операции (созданные с помощью std::async, std::packaged_task, или std::promise) могут вернуть объект типа std::future создателю этой операции.
Создатель асинхронной операции может использовать различные методы запроса, ожидания или получения значения из std::future. Этим методы могут заблокировать выполнение до получения результата асинхронной операции.
Когда асинхронная операция готова к отправке результата её создателю, она может сделать это, изменив shared state (например, std::promise::set_value), которое связано с std::future создателя.
Пример:

	```cpp
   // future from an async()
   std::future<int> f2 = std::async(std::launch::async, [](){ return 8; });

   // future from a promise
   std::promise<int> p;
   std::future<int> f3 = p.get_future();
   std::thread( [](std::promise<int>& p){ p.set_value(9); },
                std::ref(p) ).detach();
 dwd
   std::cout << "Waiting...";
   f1.wait();
   f2.wait();
   f3.wait();
   std::cout << "Done!\nResults are: "
             << f1.get() << ' ' << f2.get() << ' ' << f3.get() << '\n';
	```
	
## 21) Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры использования thread_local.
  
  Контекст потоков:
Чтобы операционная система поддерживала многозадачность, каждый выполняемый поток должен обладать своим контекстом исполнения. Этот контекст используется для хранения данных о текущем состоянии потока: значения регистров процессора, указателя на стек данных, указатель на текущую выполняемую команду.
  
  Переключение контекста потоков: 
Обновляется контекст текущего потока. Из имеющихся потоков в ОС выбирается один, который будет исполняться на процессоре. Загружается контекст выбранного потока
 
Создание объекта типа std::thread запускает новый поток.
  
До вызова деструктора объекта типа std::thread необходимо вызвать или метод join(), или метод detach(). Иначе, во время вызова деструктора произойдет вызов std::terminate().
	
	Флаг  типа  thread_local  –  основная  причина,  по  которой  мы  не  можем  использовать  для  управления  потоком  просто  класс  std::thread;  память  для  него  нужно  выделить  таким  образом,  чтобы  к  ней имел доступ как экземпляр interruptible_thread, так и вновь запущенный  поток.  Для  этого  функцию,  переданную  конструктору,  можно  специальным  образом  обернуть  перед  тем,  как  передавать  конструктору std::thread. Как это делается, показано в следующем листинге.

```cpp
class interrupt_flag{
public:
    void  set();
    bool  is_set()  const;
};
thread_local interrupt_flag this_thread_interrupt_flag;
    interruptible_thread{
    std::thread  internal_thread;
    interrupt_flag*  flag;
public:
    template<typename  FunctionType>    interruptible_thread(FunctionType  f)  {
      std::promise<interrupt_flag*> p;
      internal_thread=std::thread([f,&p]{
         p.set_value(&this_thread_interrupt_flag);
         f();
      });
      flag=p.get_future().get();
       }
      void  interrupt()  {
        if(flag)   {
          flag->set();
      }
  }
};

```
  
## 22) Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры использования std::thread.
	
		Пример использования std::thread:
```cpp
void hello() {
  std::cout << "Hello, World!";
}
 
int main() {
  std::thread th(hello);
  th.join();
}

```
	
## 23) Синхронизация потоков. Состояние гонок. Классы std::mutex, std::lock_guard, std::unique_lock. Функция std::lock. Примеры использования мьютексов.
	
	Для избежания состояния гонки следует синхронизировать потоки. Простейшим способом синхронизации потоков является взаимоисключающая блокировка.
Класс mutex является примитивом синхронизации, который может использоваться для защиты разделяемых данных от одновременного доступа нескольких потоков.
Mutex предлагает эксклюзивую, нерекурсивную семантику владения:
- Вызывающий поток владеет мьютексом со времени успешного вызова lock или try_lock, и до момента вызова unlock.
- Пока поток владеет мьютексом, все остальные потоки при попытке завладения им блокируются на вызове lock или получают значение false при вызове try_lock.
- Вызывающий поток не должен владеть мьютексом до вызова lock или try_lock.

Поведение программы не определено, если занятый некоторым потоком мьютекс разрушается или поток завершает работу и не освободил мьютекс.
	
	std::lock_guard класс. является оболочкой для mutex и позволяет реализовать идиому RAII в его отношении. Когда создается объект lock_guard, он завладевает мьютексом и исвобождает его либо при вызове декструктора, либо при вызове ```unlock()```

```C++
void safe_increment()
{
    const std::lock_guard<std::mutex> lock(g_i_mutex);
    ++g_i;
 
    std::cout << std::this_thread::get_id() << ": " << g_i << '\n';
 
    // g_i_mutex is automatically released when lock
    // goes out of scope
}
```
	
	Является аналогом lock_guard, но при этом является перемещаемым  и обладает набором вспомогательных метдов. Например ```try_lock```

Пример:
```C++
struct Box {
    explicit Box(int num) : num_things{num} {}
 
    int num_things;
    std::mutex m;
};
 
void transfer(Box &from, Box &to, int num)
{
    // don't actually take the locks yet
    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);
    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);
 
    // lock both unique_locks without deadlock
    std::lock(lock1, lock2);
 
    from.num_things -= num;
    to.num_things += num;
 
    // 'from.m' and 'to.m' mutexes unlocked in 'unique_lock' dtors
}
 
int main()
{
    Box acc1(100);
    Box acc2(50);
 
    std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);
    std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5);
 
    t1.join();
    t2.join();
}
```
	
## 24) Синхронизация потоков. Состояние гонок. Классы std::recursive_mutex, boost::shared_mutex, std::unique_lock. Функция std::lock. Пример использования std::unique_lock
	
	recursive_mutex

Данный класс помагает избежать взаимных блокировок, так как он позволяет получать самого себя несколько раз.

```
template <typename T>
class container 
{
     std::mutex _lock;
     std::vector<T> _elements;
public:
     void add(T element) 
     {
          _lock.lock();
          _elements.push_back(element);
          _lock.unlock();
     } 
     void addrange(int num, ...)
     {
          va_list arguments;
          va_start(arguments, num);
          for (int i = 0; i < num; i++)
          {
               _lock.lock();
               add(va_arg(arguments, T));
               _lock.unlock();
          }
          va_end(arguments); 
     }
     void dump()
     {
          _lock.lock();
          for(auto e: _elements)
          std::cout << e << std::endl;
          _lock.unlock();
     }
};
 
void threadFunction(container<int> &c)
{
     c.addrange(3, rand(), rand(), rand());
}
 
int main()
{
     srand((unsigned int)time(0));
     container<int> cntr;
     std::thread t1(threadFunction, std::ref(cntr));
     std::thread t2(threadFunction, std::ref(cntr));
     std::thread t3(threadFunction, std::ref(cntr));
     t1.join();
     t2.join();
     t3.join();
     cntr.dump();
     return 0;
}
```

### shared_mutex

shared_mutex – это мьютекс позволяющий одновременно многим потокам читать одни и те же данные, если в этот момент нет потоков изменяющих эти данные. 
	
## 25) Класс std::condition_variable. Потокобезопасные структуры данных с блокировками.
	
	Для синхронизации логических зависимостей между потоками, которыми можно обмениваться многократно, можно использовать условные переменные. Условные переменные предоставляют простой механизм ожидания события, возникающего в другом потоке.

Основные методы:
- ```notify_one``` уведомляет один ожидающий поток
- ```notify_all``` - уведомляет все ожидающие потоки
- ```wait``` - блокирует текущий поток до тех пор, пока переменная не будет пробужена
- ```wait_for``` - блокирует текущий поток до тех пор пока переменная условия проснулась или после указанного периода тайм-аута

Их работу удобно рассмотреть на примере шаблона паралелльного программирования Producer-Consumer. Producer, или “поставщик”, — это некоторый поток, который генерирует “задания” и складывает их в очередь. Consumer, или “потребитель”, — это поток, который обрабатывает “задачи” из очереди.

Пример:

```C++
std::mutex m;
std::queue<std::string> queue;
std::condition_variable cv;
void Producer() {
  std::lock_guard<std::mutex> lk(m);
  queue.push(ReadMessageFromNetwork());
  cv.notify_one();
}
void Consumer() {
  std::unique_lock<std::mutex> lk(m);

  while(queue.empty()) {
    cv.wait(lk);
  }
  // Используем очередь.
  lk.unlock();
  // Продолжаем выполнения потока.
}
```
	
## 26) Синхронизация потоков. Пул потоков. Класс std::condition_variable. Примеры работы с std::condition_variable
	
	Проблему огромного количества потоков в приложении призван решить пул потоков. Основной метод любого пула потоков – это метод, с помощью которого можно добавлять задачу на выполение.
- метод возвращает future на результат выполнения функции
- принимает функцию func, которую необходимо выполнить и принимает аргументы args, которые необходимо передать в функцию func во время выполнения
Аргументы повторяют аргументы функции std::async (за исключением первого параметра std::launch policy).

По факту, std::async может не создавать новый поток для исполнения задачи, а использовать поток из встроенного пула, но это зависит от конкретной реализации компилятора.

По сути, это применение шаблона producer-consumer.
В качестве consumer’ов выступают потоки, которые выполняют поставленные в очередь задачи.
В качестве producer’ов – пользовательский код.

Модификации пула потоков
Иногда, чтобы решить задачу в “виртуальном” мире достаточно посмотреть как подобная задача решается в “реальном” мире.

Динамическое добавление и снятие потоков
В магазине не на всех кассах сидят кассиры. Но в случае большой загруженности магазина на свободные кассы приходят работники.
В случае отсутствия покупателей кассиры могут выполнять другую работу, либо берут отгулы, что экономит магазину ресурсы.

Вывод:
- пул потоков предоставляет высокоуровневую абстракцию, позволяющую не задумываться о ручном управлении потоками
- пул потоков позволяет избежать накладных расходов на создание и уничтожение нового потока
- пул потоков помогает уменьшить суммарное время, затрачиваемое на переключение контекста потоков
	
## 27) Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future, функция std::async
	
	std::async  позволяет выполнить функцию асинхронно и вернуть результат как std::future, стоит отметить, что функция может быть выполнена и синхронно.

Шаблонный класс std::future обеспечивает механизм доступа к результатам асинхронных операций:

- Асинхронные операции (созданные с помощью std::async, std::packaged_task, или std::promise) могут вернуть объект типа std::future создателю этой операции.
- Создатель асинхронной операции может использовать различные методы запроса, ожидания или получения значения из std::future. Этим методы могут заблокировать выполнение до получения результата асинхронной операции.
- Когда асинхронная операция готова к отправке результата её создателю, она может сделать это, изменив shared state (например, std::promise::set_value), которое связано с std::future создателя.

Пример:
```C++
   // future from an async()
   std::future<int> f2 = std::async(std::launch::async, [](){ return 8; });

   // future from a promise
   std::promise<int> p;
   std::future<int> f3 = p.get_future();
   std::thread( [](std::promise<int>& p){ p.set_value(9); },
                std::ref(p) ).detach();
 dwd
   std::cout << "Waiting...";
   f1.wait();
   f2.wait();
   f3.wait();
   std::cout << "Done!\nResults are: "
             << f1.get() << ' ' << f2.get() << ' ' << f3.get() << '\n';
```
	
## 28) Атомарные операции. Классы std::atomic, std::atomic_flag. Примеры работы с std::atomic
	
	Операция называется атомарной, если она выполняется как единое целое, либо не выполняется вовсе. Т.е. она не может быть частично выполнена или частично не выполнена.
Если один поток выполняет атомарную операцию, то другие потоки не могут “вмешаться” в выполнение этой операции (например, получить её промежуточное значение).

### std::atomic

Каждая специализация шаблона std::atomic определяет атомарный тип. Только объекты атомарных С++ типов могут безопасно использоваться в нескольких потоках одновременно. Когда один поток сохраняет данные в объекте атомарного типа, а другой хочет их прочитать, поведение программы определено стандартом.

Доступ к атомарным переменным может использоваться для синхронизации потоков и для упорядочивания доступа к неатомарным переменным

- load() - получить текущее значение
- store() - присвоить новое значение
- is_lock_free() - возвращает true, если операции на данном типе неблокирующие
- operator++ - инкремент
- exchange() - установить новое значение и вернуть предыдущее
- compare_exchange_strong() - аналог CAS
- compare_exchange_weak() - аналог CAS

**CAS (Compare and Swap)**
Операция атомарно сравнивает значение одного объекта с другим и при равенстве измениет значение объекта.

```C++
std::atomic<int>integer(0);
std::atomic<int> otherInteger(0);
integer++;//Атомарно
otherInteger += integer++;//Не атомарно!
```

### athomic_flag

std::atomic_flag. Причина, по которой этот тип стоит особняком, – проста, это тип является простейшим атомарным объектом и представляет собой булев флаг. Он содержит свой, уникальный набор операций и, самое главное, он единственный гарантированно является свободным от блокировок! Т.е. по стандарту все операции над объектом типа std::atomic_flag являются “чисто” атомарными, без каких либо условностей. Исходя из вышесказанного можно предположить, что остальные атомарные типы, для которых не существует свободной от блокировок версии на той или иной архитектуре, будут реализованы посредством atomic_flag.

atomic_flag содержит всего две операции: test_and_set и clear, чего, собственно говоря, вполне достаточно для флага, ведь он может быть либо поднятым, либо опущенным. Но отсутствует операция проверки значения флага, без модификации оного, что сильно ограничивает сферы его использования. Так же есть набор свободных функций, которые могут оперировать флагом:
- std::atomic_flag_test_and_set
- atomic_flag_test_and_set_explicit
- atomic_flag_clear

Еще одним важным свойством atomic_flag, которое необходимо упомянуть, является его неопределенность при создании. Т.е. стандарт не оговаривает в каком состоянии находится флаг, ежели он не инициализирован. Поэтому, для получения предсказуемого результата есть смысл всегда инициализировать флаг; для этих целей существует специальный макрос ATOMIC_FLAG_INIT. Для инициализации флага, просто присвойте этот макрос вашему флагу, и, тогда, флаг инициализируется и гарантированно становится сброшенным:
```C++
std::atomic_flag flag = ATOMIC_FLAG_INIT;
```
	
## 29) Шаблоны проектирования: фабричный метод. Пример реализации «простой фабрики» и «фабричного метода».
  
  Шаблон проектирования - повторяющаяся архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.
  
  Паттерн "Простая фабрика" - это класс, в котором есть один метод с большим условным оператором, выбирающим создаваемый продукт.
  
  ```cpp
  struct Barrack {
  Unit* CreateUnit(UnitID unit_id) {
 
    switch (unit_id) {
      case UnitID::Knight:
        return new Knight();
      case UnitID::Archer:
        return new Archer();
      default:
        return nullptr;
    }
  }
};
  ```
  
  Паттерн "Фабричный метод" - это устройство классов, при котором подклассы могут переопределять тип создаваемого в суперклассе продукта.
  
  ```cpp
  struct Barrack {
  virtual Unit* CreateUnit() = 0;
 
  void Hire(Player& player) {
    auto* unit = CreateUnit();
    player.AddToArmy(unit);
  }
  
  struct KnightBarrack : public Barrack {
  Unit* CreateUnit() override {
    return new Knight();
  }
};
struct ArcherBarrack : public Barrack {
  Unit* CreateUnit() override {
    return new Archer();
  }
};
 
ArcherBarrack archer_barrack;
archer_barrack.Hire(player);
KnightBarrack knight_barrack;
knight_barrack.Hire(player);
};
  
  ```
  
## 30) Шаблоны проектирования: observer. Пример реализации «обозреватель».
  
  Observer - это поведенческий паттерн проектирования, который создает механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.
  
  ```cpp
  struct Publisher {
  struct Observer {
    virtual void OnUpdate() = 0;
  };
  void AddObserver(const Observer& observer);
  void RemoveObserver(const Observer& observer);
  void DoSomething();
 private:
  void Notify();
  std::vector<Observer*> observers_;
};
  -------------------------------------------------
  void Publisher::AddObserver(const Observer& observer) {
  observers_.push_back(&observer);
}
 
void Publisher::RemoveObserver(const Observer& observer) {
  auto it = std::remove(
      observers_.begin(), observers_.end(), &observer);
  observers_.erase(it, observers_.end());
}
 void Publisher::Notify() {
  for (auto* observer : observers_) {
    observer->OnUpdate();
  }
}
 
void Publisher::DoSomething() {
  // Выполнение некоторых действий.
  // Решаем, что необходимо умедомить наблюдателей о событии.
  Notify();
  // Продолжчаем выполнение функции.
} 
 ------------------------------------------------- 
  struct SubscriberOne : public Publisher::Observer {
  void OnUpdate() {
    // Реагирование на уведомление от Publisher'a
  }
};
struct SubscriberTwo : public Publisher::Observer {
  void OnUpdate() {
    // Реагирование на уведомление от Publisher'a
  }
};
  
  Publisher publisher;
SubscriberOne subscriber1;
SubscriberTwo subscriber2;
publisher.AddObserver(subscriber1);
publisher.AddObserver(subscriber2);
publisher.DoSomething();
  ```
  
## 31) Шаблоны проектирования: синглтон. Пример реализации Синглтона.
  
  Singletone - порождающий шаблон проектирования, гарантирующий, что в приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.
  
  ```cpp
  // Singleton.h
class Singleton {
  static Singleton* instance;
  Singleton() {}
  Singleton(const Singleton&) = delete;
  Singleton& operator=(Singleton&) = delete;
public:
 
  static Singleton * getInstance() {
    if (!instance) {
      instance = new Singleton();
    }
    return instance;
  }
};
--------------------------------------------  
  // Singleton.cpp
#include "Singleton.h"
 
Singleton* Singleton::instance = nullptr;
  ```
  
## 32) Асинхронное программирование. Плюсы и минусы. Сопрограммы. Функции обратного вызова.
	
	---
Функция std::async  позволяет  запустить  асинхронную  зада-чу,  результат  которой  прямо  сейчас  не  нужен.  Но  вместо  объекта  std::thread  она  возвращает  объект  std::future  ,  который  будет  содержать возвращенное значение, когда оно станет доступно. Когда программе понадобится значение, она вызовет функцию-член get()объекта-будущего, и тогда поток будет приостановлен до готовности будущего  результата,  после  чего  вернет  значение. 

```cpp
#include <future>
#include <iostream>
int find_the_answer_to_ltuae();
void do_other_stuff();

int main() {
std::future<int> the_answer = std::async(find_the_answer_to_ltuae); 
do_other_stuff();
std::cout << ”Ответ равен “ << the_answer.get() <<std::endl;
}

```

Шаблон std::async  позволяет  передать  функции  дополнительные  параметры,  точно  так  же,  как  std::thread.  Если  первым  аргументом  является  указатель  на  функцию-член,  то  второй  аргумент  должен  содержать  объект,  от  имени  которого  эта  функция-член  вы-зывается

```cpp
struct X {
  void foo(int,std::string const&);
  std::string bar(std::string const&);
};

X x;
auto f1=std::async(&X::foo,&x,42,”hello”);  // Вызывается p->foo(42,"hello"), где p=&x
auto f2 = std::async(&X::bar,x,”goodbye”); // Вызывается tmpx.bar("goodbye"), где tmpx – копия x

```

Также можно  задать  требуемый  режим исполнения в  дополнительном  параметре  std::async  перед  вызываемой  функцией.  Этот  параметр  имеет  тип  std::launch  и  может  принимать  сле-дующие значения: std::launch::deferred – отложить вызов функции до того момента, когда будет вызвана функция-член wait() или get() объекта-будущего; std::launch::async – запускать функцию в    отдельном    потоке;    std::launch::deferred | std::launch::async – оставить решение на усмотрение реализации.

Плюсы и минусы асинхронного подхода:
  1) Безусловный плюс — это производительность. Причем она не просто в разы выше, она выше на порядки!
  2) Минус — сложный и запутанный код, который к тому же еще и сложно отлаживать.

Сопрограммы
Сопрограммы (корутины, coroutine) - это потоки исполнения кода, которые организуются поверх аппаратных (системных) потоков.
Поток исполнения кода - это последовательность операций, которые выполняются друг за другом. В нужные моменты эта последовательность может быть приостановлена, и вместо нее может начать выполняться часть другой последовательности операций. 

В отличие от системных потоков, которые переключаются системой в произвольные моменты времени (вытесняющая многозадачность), сопрограммы переключаются вручную, в местах, указанных программистом (кооперативная многозадачность). 

Обозначим операции над сопрограммой следующим образом:
```cpp
handle = spawn(СП); - запуск сопрограммы,
yield; - приостановка текущей сопрограммы,
resume(handle); - возобновление сопрограммы.
```

Возьмем две сопрограммы:
```cpp
// СП1      |  // СП2
{           |  {
  f1();     |     g1();
  f2();     |     yield;
  yield;    |     g2();
  f3();     |     g3();
  f4();     |     yield;
  yield;    |     g4();
  f5();     |     g5();
}           |  }

```
Тогда, если на одном системном потоке запустить СП1, а затем СП2, то системный поток выполнит операции в следующем детерминированном порядке:

```cpp
// Системный поток  |  Выполняемый код
c1 = spawn(СП1);    |  f1();
                    |  f2();
c2 = spawn(СП2);    |       g1();
resume(c1);         |  f3();
                    |  f4(); 
resume(c2);         |       g2();
                    |       g3();
resume(c1);         |  f5();
resume(c2);         |       g4();
                    |       g5();

```

Функции обратного вызова

Функция обратного вызова в программировании — передача исполняемого кода в качестве одного из параметров другого кода. Обратный вызов позволяет в функции исполнять код, который задаётся в аргументах при её вызове.

```cpp
/* The calling function takes a single callback as a parameter. */
void PrintTwoNumbers(int (*numberSource)(void)) {
    int val1 = numberSource();
    int val2 = numberSource();
    printf("%d and %d\n", val1, val2);
}

/* A possible callback */
int overNineThousand(void) {
    return (rand()%1000) + 9001;
}

/* Another possible callback. */
int meaningOfLife(void) {
    return 42;
}

/* Here we call PrintTwoNumbers() with three different callbacks. */
int main(void) {
    PrintTwoNumbers(&rand);
    PrintTwoNumbers(&overNineThousand);
    PrintTwoNumbers(&meaningOfLife);
    return 0;
}

```
	
## 33) Атомарные операции. Классы std::atomic. Структуры данных без блокировок. Реализация lock-free stack
  
  ---
Операция в общей области памяти называется атомарной, если она завершается в один шаг относительно других потоков, имеющих доступ к этой памяти. Во время выполнения такой операции над переменной, ни один поток не может наблюдать изменение наполовину завершенным. Атомарная загрузка гарантирует, что переменная будет загружена целиком в один момент времени. Неатомарные операции не дают такой гарантии.

Каждая специализация шаблона ```std::atomic``` определяет атомарный тип. Только объекты атомарных С++ типов могут безопасно использоваться в нескольких потоках одновременно. Когда один поток сохраняет данные в объекте атомарного типа, а другой хочет их прочитать, поведение программы определено стандартом.

```cpp
Typedef имя		Full specialization 
std::atomic_char 	std::atomic<char>
std::atomic_schar 	std::atomic<signed char>
std::atomic_uchar 	std::atomic<unsigned char>
std::atomic_short 	std::atomic<short>
std::atomic_ushort 	std::atomic<unsigned short>
std::atomic_int 	std::atomic<int>
std::atomic_uint 	std::atomic<unsigned int>
std::atomic_long 	std::atomic<long>
```

Структуры данных и алгоритмы, в которые блокирующие библиотечные  функции  не  используются,  называются  неблокирующими. Чтобы  структура  данных  считалась  свободной  от  блокировок,  она  должна быть открыта для одновременного доступа со стороны сразу нескольких  потоков.

```cpp
template<typename T>class lock_free_stack {
private:
    struct node;
    struct counted_node_ptr {
        int external_count;
        node*  ptr;
    };

    struct node {
        std::shared_ptr<T> data;
        std::atomic<int> internal_count;
        counted_node_ptr next;
        explicit node(T const& data_): data(std::make_shared<T>(data_)), internal_count(0) {}
    };

    std::atomic<counted_node_ptr> head;

    void increase_head_count(counted_node_ptr& old_counter) {
        counted_node_ptr new_counter;
        do {
            new_counter = old_counter;
            ++new_counter.external_count;
        } while(!head.compare_exchange_strong(old_counter, new_counter, std::memory_order_acquire, std::memory_order_relaxed));
        old_counter.external_count = new_counter.external_count;
    }

public:
    ~lock_free_stack() {
        while(pop());
    }

    void push(T const& data)  {
        counted_node_ptr new_node;
        new_node.ptr = new node(data);
        new_node.external_count = 1;
        new_node.ptr->next = head.load(std::memory_order_relaxed);
        while(!head.compare_exchange_weak(new_node.ptr->next, new_node, std::memory_order_release, std::memory_order_relaxed));
    }

    std::shared_ptr<T> pop() {
        // Загружаем атомарно значение головы стека
        counted_node_ptr old_head = head.load(std::memory_order_relaxed);
        for(;;) {
            // Увеличиваем счетчик внешних ссылок на head
            // Устанавливаются  все  поля структуры, чтобы быть уверенным, что другой поток не изменил в промежутке указатель.
            increase_head_count(old_head);
            node* const ptr = old_head.ptr;

            // Проверка на пустой стек
            if(!ptr) {
                return std::shared_ptr<T>();
            }

            // Мы можем попытаться исключить узел из списка, выполнив compare_exchange_strong() с головным узлом head
            if(head.compare_exchange_strong(old_head, ptr->next, std::memory_order_relaxed)) {
                std::shared_ptr<T> res;
                // Если compare_exchange_strong()  возвращает  true,  то  мы  при-няли  на  себя  владение  узлом
                // И  можем  с  помощью  функции  swap() вытащить  из  него  данные,  которые  впоследствии  вернем
                res.swap(ptr->data);
                // мы исключили узел из списка, вследствие чего значение счетчика уменьшилось на 1
                // и больше не обращаемся к узлу из данного потока, что дает уменьше-ние еще на 1
                int const count_increase = old_head.external_count - 2;
                // Затем можно прибавить внешний счетчик к внутреннему с помощью атомарной операции fetch_add
                // fetch_add возвращает значение атомарной переменной до вызова
                // Если теперь счетчик ссылок стал равен нулю, то предыдущее значение
                // (то, которое возвращает fetch_add) было противоположно только что прибавленному, и тогда узел можно удалять.
                if(ptr->internal_count.fetch_add(count_increase, std::memory_order_release) == -count_increase) {
                    delete ptr;
                }
                return res;
                // Если сравнение не прошло, значит head модифицировали => начинаем заново
            } else if(ptr->internal_count.fetch_add(-1, std::memory_order_relaxed) == 1) {
                ptr->internal_count.load(std::memory_order_acquire);
                delete ptr;
            }
        }
    }
};

```
