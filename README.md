# ekzamen-3-sem
## 1) Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента. Реализация функции удаления элемента из двусвязного списка. Основные методы std::list. Пример работы с std::list

Каждый узел двусвязного линейного списка содержит два поля указателей — на следующий и на предыдущий узлы. Указатель на предыдущий узел корня списка и указатель на следующий узел последнего содержат нулевое значение.

Поиск элемента по значению
Сложность O(n). Проходим по всему списку и сравниваем каждый элемент с данным значением.

Вставка элемента
Сложность O(n). Сначала находим нужный элемент, затем создаём новый узел. Затем изменяем указатели.

Удалениие элемента
Сложность O(n). Аналогично вставке.

Сортировка
Для сортировки вставками алгоритмическая сложность будет равна O(n^2), т.к необходми пройти по всему списку и каждый раз вставлять элементы перед требуемым. Соответственно n^2 проходов.

Реализация удаления:

```cpp
struct node {
    void *value;
    node *next;
    node *prev;
};

struct list {
    size_t size;
    node *head;
    node *tail;
};

void* deleteNth(list *_list, size_t index) {
    node *elm = _list->head;
    void *tmp = nullptr;
    size_t i = 0;
    while (elm && i < index) {
        elm = elm->next;
        i++;
    }
    if (elm == nullptr) {
        exit(5);
    }
    if (elm->prev) {
        elm->prev->next = elm->next;
    }
    if (elm->next) {
        elm->next->prev = elm->prev;
    }
    tmp = elm->value;
    if (!elm->prev) {
        _list->head = elm->next;
    }
    if (!elm->next) {
        _list->tail = elm->prev;
    }
    delete elm;
    _list->size--;
    return tmp;
}
```

std::list - двусвязный список.

| Метод | Функция |
| --- | --- |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11)  | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| erase | Удаляет элементы
| push_back | добавляет элемент в конец |
| emplace_back  (C++11) | Конструирует элементы "на месте" в конце контейнера |
| pop_back | Удаляет последний элемент |
| push_front | вставляет элементы в начало списка |
| emplace_front  (C++11) | конструирует элементы "на месте" в начало списка |
| pop_front | удаляет первый элемент |
| resize | Изменяет количество хранимых элементов |
| swap | Обменивает содержимое |
| merge | слияние двух отсортированных списков |
| splice | перемещает элементы из другого list |
| remove / remove_if | удаляет элементы, удовлетворяющие определенным критериям |
| reverse | инвертирует порядок элементов |
| unique | удаляются последовательно повторяющиеся элементы |
| sort | сортирует элементы |

Пример работы с std::list:

```cpp
std::list<int> numbers{1, 2, 4, 5};
if (numbers.empty())
    std::cout << "The list is empty" << std::endl;
else
    std::cout << "The list is not empty" << std::endl;
numbers.push_back(23);  
numbers.push_front(15); 
```

## 2) Класс std::map. Внутренняя реализация map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::map

std::map — отсортированный ассоциативный контейнер, который содержит пары ключ-значение с неповторяющимися ключами. Порядок ключей задаётся функцией сравнения Compare. Данный тип, как правило, реализуется как красно-чёрное дерево.

Красно-чёрное дерево — один из видов из самобалансирующихся двоичных деревьев поиска, гарантирующих логарифмический рост высоты дерева от числа узлов и позволяющее быстро выполнять основные операции дерева поиска: добавление, удаление и поиск узла. Сбалансированность достигается за счёт введения дополнительного атрибута узла дерева — «цвета». Этот атрибут может принимать одно из двух возможных значений — «чёрный» или «красный».

### Основыне методы

| Метод | Функция |
| --- | --- |
| at  (C++11) | Предоставляет доступ к указанному элементу с проверкой индекса |
| operator[] | Предоставляет доступ к указанному элементу |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11) | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| emplace_hint  (C++11) | Элементы конструкций на месте использования подсказки |
| erase | Удаляет элементы |
| swap | Обменивает содержимое |
| count | Возвращает количество элементов, соответствующих определенному ключу |
| find | находит элемент с конкретным ключом |
| equal_range | возвращает набор элементов для конкретного ключа |
| lower_bound | возвращает итератор на первый элемент не меньше, чем заданное значение |
| upper_bound | возвращает итератор на первый элемент больше, чем определенное значение |
| key_comp | возвращает функцию, сравнивающую ключи |
| value_comp | возвращает функцию, сравнивающую значения |

### Сложности основных алгоритмов

1. Поиск по ключу - O(log(n))
2. Сортировка - O
3. Вставка - O(log(n))
4. Удаление - O(log(n))

### Пример использования

```cpp
 int main()
{
    std::map<std::string, int> m { {"CPU", 10}, {"GPU", 15}, {"RAM", 20}, };
 
    m["CPU"] = 25;  
    m["SSD"] = 30;  
 
    for (const auto& [key, value] : m) {
        std::cout << key << " = " << value << "; ";
    }
}
```

## 3) Класс std::set. Внутренняя реализация set, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::set

std::set — ассоциативный контейнер, который содержит упорядоченный набор уникальных объектов типа Key. Сортировка элементов осуществляется применением функции Compare к ключам множества. Данный тип обычно реализуется как красно-черные деревья.

### Основные методы

| Метод | Функция |
| --- | --- |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11) | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| emplace_hint  (C++11) | Элементы конструкций на месте использования подсказки |
| erase | Удаляет элементы |
| swap | Обменивает содержимое |
| count | Возвращает количество элементов, соответствующих определенному ключу |
| find | находит элемент с конкретным ключом |
| equal_range | возвращает набор элементов для конкретного ключа |
| lower_bound | возвращает итератор на первый элемент не меньше, чем заданное значение |
| upper_bound | возвращает итератор на первый элемент больше, чем определенное значение |
| key_comp | возвращает функцию, сравнивающую ключи |
| value_comp | возвращает функцию, сравнивающую значения |

### Сложности основных алгоритмов

1. Поиск - O(log(n))
2. Вставка - O(log(n))
3. Удаление - O(log(n))

### Пример работы с std::set:
```cpp
int main()
{
  std::set<std::string> a;
  a.insert("cat");
  a.insert("dog");
  a.insert("horse");
  for(auto& str: a) std::cout << str << ' ';
}
```

## 4) Класс std::unordered_map. Внутренняя реализация unordered_map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::unordered_map

Unordered map является ассоциативным контейнером, который содержит пары ключ-значение с уникальными ключами. Поиск, вставка и удаление выполняются за константное время.

### Основные методы

| Метод | Функция |
| --- | --- |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| emplace_hint | Элементы конструкций на месте использования подсказки |
| erase | Удаляет элементы |
| swap | Обменивает содержимое |
| at | Предоставляет доступ к указанному элементу с проверкой индекса |
| operator[] | Предоставляет доступ к указанному элементу |
| count | Возвращает количество элементов, соответствующих определенному ключу |
| find | находит элемент с конкретным ключом |
| equal_range | возвращает набор элементов для конкретного ключа |
| begin(int) cbegin(int) | возвращает итератор на начало указанного сегмента |
| end(int) cend(int) | возвращает итератор на конец указанного сегмента |
| bucket_count | Возвращает количество bucket'ов |
| max_bucket_count | Возвращает максимальное количество bucket'ов |
| bucket_size | Возвращает количество элементов в конкретном bucket'е |
| bucket | Возвращает bucket для конкретного ключа |
| load_factor | Возвращает среднее количество элементов на bucket |
| max_load_factor | Управляет максимальным средним количеством элементов на bucket |
| rehash | Резервирует количество bucket'ов, не меньшее запрошенного, соответственно перестраивая хэш-таблицу. |
| reserve | Запасает место для, как минимум, указанного числа элементов. Это восстанавливает хэш-таблицу. |

### Пример работы с std::unordered_map:
```cpp
int main()
{
    // Create an unordered_map of three strings (that map to strings)
    std::unordered_map<std::string, std::string> u = {
        {"RED","#FF0000"},
        {"GREEN","#00FF00"},
        {"BLUE","#0000FF"}
    };
 
    std::cout << "Iterate and print keys and values of unordered_map, being explicit with\n"
                 "the type of the iterator, n:\n";
    for( const std::pair<std::string, std::string>& n : u ) {
        std::cout << "Key:[" << n.first << "] Value:[" << n.second << "]\n";
    }
}
```

## 5) Класс std::vector. Внутренняя реализация vector, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::vector. Особенность std::vector<bool>.
  
  Элементы хранятся непрерывно, а значит доступны не только через итераторы, но и через смещения, добавляемые к указателям на элементы. Это означает, что указатель на элемент вектора может передаваться в любую функцию, ожидающую указатель на элемент массива.
    
Хранилище вектора обрабатывается автоматически, расширяясь и сужаясь по мере необходимости. Векторы обычно занимают больше места, чем статические массивы, поскольку некоторое количество памяти выделяется про запас на обработку будущего роста. Память для вектора требуется выделять не при каждой вставке элемента, а только после исчерпания резервов. Общий объём выделенной памяти можно получить с помощью функции capacity(). Резервная память может быть возвращена системе через вызов shrink_to_fit(). Перераспределения обычно являются дорогостоящими операциями в плане производительности. Функция reserve() может использоваться для предварительного выделения памяти и устранения перераспределений, если заранее известно количество элементов.

### Основные методы

| Метод | Функция |
| --- | --- |
| at | Предоставляет доступ к указанному элементу с проверкой индекса |
| operator[] | Предоставляет доступ к указанному элементу |
| front | Предоставляет доступ к первому элементу |
| back | предоставляет доступ к последнему элементу |
| data  (C++11) | Предоставляет прямой доступ к внутреннему содержимому |
| empty | Проверяет отсутствие элементов в контейнере |
| size | Возвращает количество элементов в контейнере |
| max_size | Возвращает максимально допустимое количество элементов в контейнере |
| reserve | Зарезервировать память. |
| capacity | Возвращает количество элементов, которые могут одновременно храниться в выделенной области памяти |
| shrink_to_fit  (C++11) | Уменьшает использование памяти, высвобождая неиспользуемую |
| clear | Очищает контейнер |
| insert | Вставляет элементы |
| emplace  (C++11) | Конструирует элементы "на месте" и вставляет их начиная с заданной позиции pos |
| erase | Удаляет элементы |
| push_back | добавляет элемент в конец |
| emplace_back  (C++11) | Конструирует элементы "на месте" в конце контейнера |
| pop_back | Удаляет последний элемент |
| resize | Изменяет количество хранимых элементов |
| swap | Обменивает содержимое |

### Сложности основных алгоритмов

1. Произвольный доступ — постоянная O(1)
2. Вставка и удаление элементов в конце — амортизированная постоянная O(1)
3. Вставка и удаление элементов — линейная по расстоянию до конца вектора O(n)
    
    Пример работы с std::vector:
    
    ```cpp
    int main()
{
    std::vector<int> v = { 7, 5, 16, 8 };
 
    v.push_back(25);
    v.push_back(13);

    for (int n : v) {
        std::cout << n << ", ";
    }
}
    ```

### Особенность std::vector<bool>

Способ, которым std::vector <bool> сделан компактным, определяется реализацией. Одной из потенциальных оптимизаций является сливание векторных элементов таким образом, что каждый элемент занимает один бит, а не байт, как обычный элемент типа bool.

std::vector< bool > ведет себя аналогично std::vector, но для того, чтобы быть компактным, он:
- Не обязательно хранит свои данные в одном непрерывном куске памяти.
- Предоставляет std::vector<bool>::reference как метод доступа к отдельным битам.
- Не использует std::allocator_traits::construct чтобы построить битовые значения.
  
## 6) Парадигмы ООП. Полиморфизм (статический, динамический). Инкапсуляция. Наследование. Примеры.

 Инкапсуляция - объединение кода и данных таким образом, чтобы защищать данные от непреднамеренного использования и внешнего вмешательства. Основные типы доступа: private, protected, public.

  Наследование - приобретение одним объектом свойств другого. Объект может унаследовать характерные черты одного объекта и внести в них изменения, характерные только для него.

Полиморфизм - использование одно и того же имени для решения схожих, но технически разных задач. Целью полиморфизма является использование одного имени для задания общих для класса действий.

Статический полиморфизм реализуется с помощью шаблонов классов. Класс создаётся во время компиляции из шаблона (статическое связывание)

Пример:
```C++
template <typename T>
class Comparison {
public:
    T max(T a, T b) {
        return (a > b) ? a : b;
    }
    T min(T a, T b) {
        return (a < b) ? a : b;
    }
};
```

Диинамический полиморфизм реализуется с помощью перезагрузки функций и абстрактного базового класса. Динамическое связывание происходит во время исполнения программы.

Пример:
```C++
class Comparison {
public:
    int max(int a, int b);
    double max(double a, double b);
};
```
    
## 7) Разработка обобщенных типов: шаблоны С++. Инстанцирование. Спецификация шаблонов. Примеры.
                      
Механизм шаблонов в языке С++ позволяет решать проблему унификации алгоритма для различных типов.

Пример шаблонной функции:
```C++
template<class T>
T _min(T a, T b){
    if( a < b){
        return a;
    }
    return b;
}
```

### Инстанциирование

Шаблон класса сам по себе не является ни типом, ни объектом, ни любой другой сущностью. Из исходного файла, содержащего только определения шаблонов, не генерируется никакого кода. Чтобы компилятор сгенерировал код, данный шаблон должен быть инстанцирован, для чего из шаблона должен быть создан конкретный класс с набором аргументов (или функция для шаблона функции).

Явное определение инстанцирования осуществляет непосредственное инстанцирование класса, структуры или объединения. Такое определение может быть сделано в любом месте программы после определения шаблона, а для заданного списка аргументов, может быть указано только один раз во всей программе.

Пример:
```C++
namespace N
{
  template<class T>
  class Y // определение шаблона
  {
    void mf() { }
  };
}
    
// template class Y<int>; 	  // ошибка: шаблон класса Y не видим в глобальном пространстве имён
using N::Y;
// template class Y<int>; 	  // ошибка: явное инстанцирование вне пространства имён шаблона
template class N::Y<char*>;       // OK: явное инстанцирование
template void N::Y<double>::mf(); // OK: явное инстанцирование
```

Когда код ссылается на шаблон в контексте, который требует полностью определённого типа, или когда полнота типа влияет на код, и этoт конкретный тип не был явно инстанцирован, то происходит неявное инстанцирование. Например, когда создаётся объект этoго типа, но не указатель на этoт тип. Это применимо и к членам шаблона класса - если данный член не использован в программе, то он не инстанцируется и не требует определения.

Пример:
```C++
template<class T>
struct Z // определение шаблона
{
    void f() {}
    void g(); // нет определения
};
template struct Z<double>; // явное инстанцирование Z<double>
Z<int> a; 		   // неявное инстанцирование Z<int>
Z<char>* p; 		   // здесь ничего не инстанцируется
p->f(); 		   // здесь происходит неявное инстанцирование Z<char> и Z<char>::f().
```

Спецификация шаблона - написание реализации для конкретного типа. Если эта версия шаблона функции в коде не используется, то она не будет включена в бинарный код.

```C++
template<>
std::string _min(std::string a, std::string b){
    if(a.size() < b.size()){
        return a;
    }
    return b;
}
```
                      
## 8) Итераторы: определение, назначение, преимущества. Итераторы прямого доступа, итераторы ввода, итераторы вывода, двунаправленные итераторы, прямой итератор. Примеры.

Итераторе - указатель на определённый элемент контейнерного класса с дополнительным набором перегруженных операторов для выполнения чётко определённых функций:

-   Оператор * возвращает элемент, на который в данный момент указывает итератор.

-   Оператор ++ перемещает итератор к следующему элементу контейнера. Большинство итераторов также предоставляют оператор −− для перехода к предыдущему элементу.

-   Операторы == и != используются для определения того, указывают ли два итератора на один и тот же элемент или нет. Для сравнения значений, на которые указывают два итератора, нужно сначала разыменовать эти итераторы, а затем использовать оператор == или !=.

-   Оператор = присваивает итератору новую позицию (обычно начало или конец элементов контейнера). Чтобы присвоить значение элемента, на который указывает итератор, другому объекту, нужно сначала разыменовать итератор, а затем использовать оператор =.

Каждый контейнерный класс имеет 4 основных метода для работы с оператором =:

-   begin() возвращает итератор, представляющий начало элементов контейнера.

-   end() возвращает итератор, представляющий элемент, который находится после последнего элемента в контейнере.

-   cbegin() возвращает константный (только для чтения) итератор, представляющий начало элементов контейнера.

-   cend() возвращает константный (только для чтения) итератор, представляющий элемент, который находится после последнего элемента в контейнере.

### Преимущества

В процедурных языках программирования широко используется индексация, основанная на счётчике цикла, для перебора всех элементов последовательности (например, массива). Хотя индексация может использоваться совместно с некоторыми объектно-ориентированными контейнерами, использование итераторов даёт свои преимущества:

Индексация не подходит для некоторых структур данных, в частности, для структур данных с медленным произвольным доступом или вообще без поддержки такового (например, список или дерево).
Итераторы предоставляют возможность последовательного перебора любых структур данных, поэтому делают код более читаемым, удобным для повторного использования и менее чувствительным к изменениям структур данных.

Итераторы могут предоставлять дополнительные возможности при навигации по элементам. Например, проверку отсутствия пропусков элементов или защиту от повторного перебора одного и того же элемента.
Некоторые контейнеры могут предоставлять возможность модифицировать свои объекты без влияния на сам итератор. Например, после того, как итератор уже «прошёл» первый элемент, можно вставить дополнительные элементы в начало контейнера без каких-либо нежелательных последствий. При использовании индексации это проблематично из-за смены номеров индексов.

### Типы итераторов

##### Итератор ввода

```Input iterator``` предназначен только для однократного чтения (ввода) последовательности значений.
```C++
Value value = *it++; // прочитать следующее значение, it - итератор
```
Итератор можно передвигать на одну позицию вперед (инкремент) и разыменовывать (операции * и ->), получая доступ к текущему значению. Итераторы можно сравнивать между собой на равенство и неравенство.

##### Итератор вывода

```Output iterator``` предназначен только для однократной записи (вывода) последовательности. В остальном аналогичен итератору ввода.
```C++
*it++ = value;
```
##### Однонаправленный итератор

```Forward iterator``` является расширением концепции “итератор ввода”, т.е. предоставляет возможности итератора ввода (и, возможно, но не гарантированно, итератора вывода). Кроме того, однонаправленный итератор допускает многократное чтение и запись линейной последовательности, по которой можно двигаться только в одну сторону (как по односвязному списку — “вперёд” с помощью операции ++).

##### Двунаправленный итератор

```bidirectional iterator``` является расширением концепции “однонаправленный итератор”. Двунаправленный итератор допускает движение в двух направлениях: вперед (с помощью ++) и назад (с помощью операции --).

##### Итератор произвольного доступа

```random access iterator``` является расширением концепции “двунаправленный итератор” и наиболее похож по своему поведению на обычный указатель на элемент массива (который является частным случаем итератора произвольного доступа).

Итератор произвольного доступа допускает адресацию по индексу (оператор []), сдвиг в обе стороны на некоторое количество позиций (добавление и вычитание целого числа), вычисление расстояния с помощью вычитания и сравнение на “меньше” и “больше” (согласованное с расстоянием, которое имеет знак).
                    
## 9) Современный С++: auto, decltype, range base loop, nullptr, constexpr, enum class, if constexpr.
    
    ### auto

До С++11, ключевое слово auto использовалось как спецификатор хранения переменной (как, например, register, static, extern). В С++11 auto позволяет не указывать тип переменной явно, говоря компилятору, чтобы он сам определил фактический тип переменной, на основе типа инициализируемого значения.
    
    ```cpp
    for (auto i : vec) {
        cout << i << endl;
    }
    ```

### decltype

```Decltype``` позволяет статически определить тип по типу другой переменной.

```C++
int x = 5;
double y = 5.1;

decltype(x) foo;    // int
decltype(y) bar;    // double
decltype(x+y) baz;  // double
```

### Range based loop

```Range-Based for``` — это цикл по контейнеру.

```C++
for (int& x : foo)
    x *= 2;

for (const int& x : foo)
    std::cout << x << std::endl;
```

### nullptr

Раньше, для обнуления указателей использовался макрос NULL, являющийся нулем — целым типом, что, естественно, вызывало проблемы (например, при перегрузке функций). Ключевое слово nullptr имеет свой собственный тип std::nullptr_t, что избавляет нас от бывших проблем. Существуют неявные преобразования nullptr к нулевому указателю любого типа и к bool (как false), но преобразования к целочисленных типам нет.

```C++
void foo(int* p) {}

void bar(std::shared_ptr<int> p) {}

int* p1 = NULL;
int* p2 = nullptr;   

if(p1 == p2)
{}

foo(nullptr);
bar(nullptr);

bool f = nullptr;
int i = nullptr; // ошибка: для преобразования в int надо использовать reinterpret_cast
```

### Constexpr

С помощью него можно создавать переменные, функции и даже объекты, которые будут рассчитаны на этапе компиляции. Это удобно, ведь раньше для таких целей приходилось использовать шаблоны.

##### constexpr-функция

Ключевое слово constexpr, добавленное в C++11, перед функцией означает, что если значения параметров возможно посчитать на этапе компиляции, то возвращаемое значение также должно посчитаться на этапе компиляции. Если значение хотя бы одного параметра будет неизвестно на этапе компиляции, то функция будет запущена в runtime (а не будет выведена ошибка компиляции).

##### constexpr-переменная

Ключевое слово в данном случае означает создание константы. Причем expression должно быть известно на этапе компиляции.

```C++
int sum (int a, int b)
{
	return a + b;
}

constexpr int new_sum (int a, int b)
{
	return a + b;
}

void func()
{
	constexpr int a1 = new_sum (5, 12); // ОК: constexpr-переменная
	constexpr int a2 = sum (5, 12); // ошибка: функция sum не является constexp-выражением
	int a3 = new_sum (5, 12); // ОК: функция будет вызвана на этапе компиляции
	int a4 = sum (5, 12); // ОК
}
```

### enum-class

Перечисление представляет собой особый тип, значение которого ограничивается одной из нескольких явно именованных констант ("счетчики"). Значения констант - это значения целого типа, известного также как базовый тип перечисления.

```C++
enum color {
    red,            //присваевается 0
    yellow,         //присваевается 1
    green = 20,     //присваевается 20
    blue            //присваевается 21
};  
```
    
    ### if constexpr
    
    if constexpr вычисляется во время компиляции, а if - нет. Это означает, что ветви могут быть отклонены во время компиляции и, следовательно, никогда не будут скомпилированы.
    
    ```cpp
    template <typename T>
void mixStaticWithDynamicIncorrect(T val)
{
    if constexpr(std::is_integral<T>::value)
        std::cout << "Integral passed.";
    else if(val == std::string{"clone"})
        std::cout << "Known string passed.";
    else if constexpr(std::is_same_v<T, std::string>)
        std::cout << "General string passed.";
    else
        std::cout << "Unknown type variable passed.";
    std::cout << "\n";
}
    ```
    
## 10) Современный С++: static_assert, initializer_list, default, final, override, using
    
    ### static_assert

В C++11 добавили ещё один тип ```assert```-а — ```static_assert```. В отличие от assert, который выполняется во время выполнения, static_assert выполняется во время компиляции, вызывая ошибку компилятора, если условие не является истинным. Если условие ложное, то выводится диагностическое сообщение.

```C++
static_assert(sizeof(long) == 8, "long must be 8 bytes");
static_assert(sizeof(int) == 4, "int must be 4 bytes");
```

    ###  Конструкторы принимающие initializer_list

Конструкторы, походящие на конструкторы контейнеры, принимающие значения в угловых скобках. Реализованны данные конструкторы посредством класса std::initializer_list, что позволяет упростить множественное присваивание.
    
     ```cpp
    template <class T>
    struct S {
        std::vector<T> v;
        S(std::initializer_list<T> l) : v(l) {
            std::cout << "constructed with a " << l.size() << "-element list\n";
        }
    };
 
    int main()
    {
        S<int> s = {1, 2, 3, 4, 5}; // copy list-initialization
    }
    ```

    ### default

Суть его заключается в том, что пользователь может указать компилятору реализовать ту или иную функцию-член класса по-умолчанию.

```cpp
class Foo
{
public:
    Foo() = default;
    Foo(int x) {/* ... */}
};
```
    
    ### Final

Ключевое слово позволяет запретить переопределение виртуального метода в дочернем классе. Также  ```final``` может запретить использование класса как базового в дальнейшем

Пример:
```C++
struct Base
{
    virtual void foo();
};

struct A : Base
{
    void foo() final; // Base::foo is overridden and A::foo is the final override
    void bar() final; // Error: non-virtual function cannot be overridden or be final
};

struct B final : A // struct B is final
{
    void foo() override; // Error: foo cannot be overridden as it's final in A
};

struct C : B // Error: B is final
{
};
```

    ### Override

Ключевое слово ```override``` следует после объявления метода и означает, что данный метод является виртуальным и переобределяет метод базового класса. Если такого метода в базовом классе нет, компилятор сообщает об этом.

Пример для ```virtual``` и ```override```:
```C++
class figure
{
protected:
  double x, y;
public:
  figure(double a = 0, double b = 0) { x = a; y = b; }
  virtual double area() {return(0);}
};
class rectangle : public figure
{
public:
  rectangle(double a = 0, double b = 0) : figure(a, b) {};
  double area() override {return(x*y);}
};
class circle : public figure
{
public:
  circle(double a = 0) : figure(a, 0) {};
  double area() override {return(3.14*x*x);}
};
```
    
  ### using

С появлением шаблонов в C++, добавление синонимов стало достаточно трудным с использованием ```typedef```, соответсвенно для решения этой проблемы, а также упрощения кода в стандарт был добавлена using.  
    
    ```cpp
    using std::string
    ```
    
## 11) Современный С++: std::optional, std::variant, std::any, std::string_view. Примеры использования
## 12) Лямбда-функции, функторы, указатели на функции, std::functional. Примеры использования std::functional. Примеры использования лямбда-функций.
## 13) R-value ссылки. Семантика перемещения. std::move, std::forward. Пример.
  
  Rvalue ссылки - техническое расширение языка C++. Они позволяют компилятору определить, когда необходимо использовать перемещение, вместо копирования. 
  
  Семантика перемещения позволяет компиляторам заменять дорогостоящие операции копирования "дешевыми" операциями перемещения. Семантика также позволяет создавать типы, которые концептуальлно поддерживают только опферации перемещения. 
  
  std::move безусловно приводит аргумент фк ravalue ссылке.
  
  ```cpp
    std::string str = "Salut";
    std::vector<std::string> v;
 
    v.push_back(str);
    std::cout << "After copy, str is " << str << '\n';
 
    v.push_back(std::move(str));
    std::cout << "After move, str is " << str << '\n';
 
    std::cout << "The contents of the vector are { " << std::quoted(v[0])
                                             << ", " << std::quoted(v[1]) << " }\n";
  ```
  
  Функция std::forward применяется при идеальной передаче (perfect forwarding). Идеальная передача позволяет создавать функции-обертки, передающие параметры без каких-либо изменений (lvalue передаются как lvalue, а rvalue – как rvalue).
  
  ```cpp
  void push(T&& value) {
    T* data = new T[length];
    if (length) {
      for (unsigned int i = 0; i < length; ++i) data[i] = forward<T>(ptr[i]);
    }
    delete[] ptr;
    ++length;
    ptr = new T[length];
    for (unsigned int i = 0; i < length - 1; ++i) ptr[i] = forward<T>(data[i]);
    delete[] data;
    ptr[length - 1] = forward<T>(value);
  }
  ```
  
## 14) Обработка ошибок с использованием механизма обработки исключений. RAII. Примеры классов, использующих RAII. Ключевое слово noexcept.
  
  Пример обработки ошибок с использованием механизма обработки исключений:
  ```cpp
  try
{
    // Здесь мы пишем стейтменты, которые будут генерировать следующее исключение
    throw -1; // типичный стейтмент throw
}
 
  catch (int a)
{
    // Обрабатываем исключение типа int
    std::cerr << "We caught an int exception with value" << a << '\n';
}
  ```
  
  Идиома RAII
Resource Acquisition Is Initialization - идиома объектно-ориентированного программирования, смысл которой заключается в том, что получение некоторого ресурса неразрывно совмещается с инициализацией объекта, а освобождение — с уничтожением.
  
  RAII
Другими словами, выделяем память (или любой другой ресурс) в конструкторе некого объекта, а освобождаем - в деструкторе.
  
  Классы использующие RAII: boost::scooped_ptr, std::unique_ptr, std::shared_ptr, std::weak_ptr.

  Noexept - метод с помощью которого программист сообщает компилятору, должна ли функция создавать исключения. 
  
## 15) RAII. «Умные» указатели. std::shared_ptr. Примеры.
  
  RAII см. 14 вопрос

  Указатель std::shared_ptr используется для управления ресурсами путем совместного владения, т.е. объект, на который указывает shared_ptr, унитожится только после того, как не останется ни одного shared_ptr ссылающегося на него.
  
  std::shared_ptr является копируемым и перемещаемым.
  
  Подсчет ссылок в shared_ptr построен с помощью атомарного счетчика, Можно безопасно использовать указатели лна один и тот же объект из разных потоков. 
  
  ``` cpp
  std::shared_ptr ptr(new Image("~/Photo.png"));
  
  std::shared_ptr another_ptr = ptr;
  assert(ptr != nullptr);
  assert(another_ptr != nullptr);
  
  std::yet_another_ptr = std::move(ptr);
  assert(ptr == nullptr);
  assert(yet_another_ptr != nullptr);
  ```

## 16) RAII. «Умные» указатели. std::unique_ptr. Примеры.\
  
  RAII см. 14 вопрос
  
  std::unique_ptr - владеет объектом, на который указывает, т.е. отвечает за уничтожение объекта и освобождение памяти.
  
  std::unique_ptr - является некопируемый, но перемещаемым объектом. При попытке копировать std::unique_ptr получим ошибку компиляции.
  
  По умолчанию, std::unique_ptr имеет тот же размер, что и обычные указатели. Для большинства операций выполняются точно такие же команды. Следовательно std::unique_ptr можно использовать, когда важны расход памяти и времени.
  
  Совместим с stl-контейнером. Поддерживает custom deleater.
  
  ``` cpp
  std::unique_ptr ptr(new Image("~/photo.png"));
  std::unique_ptr amother_ptr = std::move(ptr);
  assert(ptr == nullptr);
  assert(another_ptr != nullptr);
  ```
  ## 17) RAII. «Умные» указатели. std::weak_ptr. Примеры.
  
  RAII см. 14 вопрос
  
  Умный указатель std::weak_ptr был разработан для решения проблемы «циклической зависимости». std::weak_ptr является наблюдателем — он может наблюдать и получать доступ к тому же объекту, на который указывает std::shared_ptr (или другой std::weak_ptr), но не считаться владельцем этого объекта.
  
  ```cpp
  weak_ptr<Parent> parentWeakPtr_ = parentSharedPtr;
  shared_ptr<Parent> tempParentSharedPtr = parentWeakPtr_.lock();
if( !tempParentSharedPtr ) {
  // yes, it may fail if the parent was freed since we stored weak_ptr
} else {
  // do stuff
}
```
  
## 18) Сетевое взаимодействие. Berkley sockets. Основные функции для работы с сокетами
## 19) Сетевое взаимодействие. Сокеты. Библиотека boost asio.
## 20) Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future, функция std::async.
## 21) Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры использования thread_local.
  
  Контекст потоков:
Чтобы операционная система поддерживала многозадачность, каждый выполняемый поток должен обладать своим контекстом исполнения. Этот контекст используется для хранения данных о текущем состоянии потока: значения регистров процессора, указателя на стек данных, указатель на текущую выполняемую команду.
  
  Переключение контекста потоков: 
Обновляется контекст текущего потока. Из имеющихся потоков в ОС выбирается один, который будет исполняться на процессоре. Загружается контекст выбранного потока
 
Создание объекта типа std::thread запускает новый поток.
  
До вызова деструктора объекта типа std::thread необходимо вызвать или метод join(), или метод detach(). Иначе, во время вызова деструктора произойдет вызов std::terminate().
  
## 22) Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры использования std::thread.
## 23) Синхронизация потоков. Состояние гонок. Классы std::mutex, std::lock_guard, std::unique_lock. Функция std::lock. Примеры использования мьютексов.
## 24) Синхронизация потоков. Состояние гонок. Классы std::recursive_mutex, boost::shared_mutex, std::unique_lock. Функция std::lock. Пример использования std::unique_lock
## 25) Класс std::condition_variable. Потокобезопасные структуры данных с блокировками.
## 26) Синхронизация потоков. Пул потоков. Класс std::condition_variable. Примеры работы с std::condition_variable
## 27) Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future, функция std::async
## 28) Атомарные операции. Классы std::atomic, std::atomic_flag. Примеры работы с std::atomic
## 29) Шаблоны проектирования: фабричный метод. Пример реализации «простой фабрики» и «фабричного метода».
  
  Шаблон проектирования - повторяющаяся архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.
  
  Паттерн "Простая фабрика" - это класс, в котором есть один метод с большим условным оператором, выбирающим создаваемый продукт.
  
  ```cpp
  struct Barrack {
  Unit* CreateUnit(UnitID unit_id) {
 
    switch (unit_id) {
      case UnitID::Knight:
        return new Knight();
      case UnitID::Archer:
        return new Archer();
      default:
        return nullptr;
    }
  }
};
  ```
  
  Паттерн "Фабричный метод" - это устройство классов, при котором подклассы могут переопределять тип создаваемого в суперклассе продукта.
  
  ```cpp
  struct Barrack {
  virtual Unit* CreateUnit() = 0;
 
  void Hire(Player& player) {
    auto* unit = CreateUnit();
    player.AddToArmy(unit);
  }
  
  struct KnightBarrack : public Barrack {
  Unit* CreateUnit() override {
    return new Knight();
  }
};
struct ArcherBarrack : public Barrack {
  Unit* CreateUnit() override {
    return new Archer();
  }
};
 
ArcherBarrack archer_barrack;
archer_barrack.Hire(player);
KnightBarrack knight_barrack;
knight_barrack.Hire(player);
};
  
  ```
  
## 30) Шаблоны проектирования: observer. Пример реализации «обозреватель».
  
  Observer - это поведенческий паттерн проектирования, который создает механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.
  
  ```cpp
  struct Publisher {
  struct Observer {
    virtual void OnUpdate() = 0;
  };
  void AddObserver(const Observer& observer);
  void RemoveObserver(const Observer& observer);
  void DoSomething();
 private:
  void Notify();
  std::vector<Observer*> observers_;
};
  -------------------------------------------------
  void Publisher::AddObserver(const Observer& observer) {
  observers_.push_back(&observer);
}
 
void Publisher::RemoveObserver(const Observer& observer) {
  auto it = std::remove(
      observers_.begin(), observers_.end(), &observer);
  observers_.erase(it, observers_.end());
}
 void Publisher::Notify() {
  for (auto* observer : observers_) {
    observer->OnUpdate();
  }
}
 
void Publisher::DoSomething() {
  // Выполнение некоторых действий.
  // Решаем, что необходимо умедомить наблюдателей о событии.
  Notify();
  // Продолжчаем выполнение функции.
} 
 ------------------------------------------------- 
  struct SubscriberOne : public Publisher::Observer {
  void OnUpdate() {
    // Реагирование на уведомление от Publisher'a
  }
};
struct SubscriberTwo : public Publisher::Observer {
  void OnUpdate() {
    // Реагирование на уведомление от Publisher'a
  }
};
  
  Publisher publisher;
SubscriberOne subscriber1;
SubscriberTwo subscriber2;
publisher.AddObserver(subscriber1);
publisher.AddObserver(subscriber2);
publisher.DoSomething();
  ```
  
## 31) Шаблоны проектирования: синглтон. Пример реализации Синглтона.
  
  Singletone - порождающий шаблон проектирования, гарантирующий, что в приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.
  
  ```cpp
  // Singleton.h
class Singleton {
  static Singleton* instance;
  Singleton() {}
  Singleton(const Singleton&) = delete;
  Singleton& operator=(Singleton&) = delete;
public:
 
  static Singleton * getInstance() {
    if (!instance) {
      instance = new Singleton();
    }
    return instance;
  }
};
--------------------------------------------  
  // Singleton.cpp
#include "Singleton.h"
 
Singleton* Singleton::instance = nullptr;
  ```
  
## 32) Асинхронное программирование. Плюсы и минусы. Сопрограммы. Функции обратного вызова.
## 33) Атомарные операции. Классы std::atomic. Структуры данных без блокировок. Реализация lock-free stack
  
  
