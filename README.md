# ekzamen-3-sem
## 1) Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента. Реализация функции удаления элемента из двусвязного списка. Основные методы std::list. Пример работы с std::list
## 2) Класс std::map. Внутренняя реализация map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::map
## 3) Класс std::set. Внутренняя реализация set, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::set
## 4) Класс std::unordered_map. Внутренняя реализация unordered_map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std:: unordered_map
## 5) Класс std::vector. Внутренняя реализация vector, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::vector. Особенность std::vector<bool>.
## 6) Парадигмы ООП. Полиморфизм (статический, динамический). Инкапсуляция. Наследование. Примеры.
## 7) Разработка обобщенных типов: шаблоны С++. Инстанцирование. Спецификация шаблонов. Примеры.
## 8) Итераторы: определение, назначение, преимущества. Итераторы прямого доступа, итераторы ввода, итераторы вывода, двунаправленные итераторы, прямой итератор. Примеры.
## 9) Современный С++: auto, decltype, range base loop, nullptr, constexpr, enum class, if constexpr.
## 10) Современный С++: static_assert, initializer_list, default, final, override, using
## 11) Современный С++: std::optional, std::variant, std::any, std::string_view. Примеры использования
## 12) Лямбда-функции, функторы, указатели на функции, std::functional. Примеры использования std::functional. Примеры использования лямбда-функций.
## 13) R-value ссылки. Семантика перемещения. std::move, std::forward. Пример.
## 14) Обработка ошибок с использованием механизма обработки исключений. RAII. Примеры классов, использующих RAII. Ключевое слово noexcept.
## 15) RAII. «Умные» указатели. std::shared_ptr. Примеры.
  Идиома RAII
Resource Acquisition Is Initialization - идиома объектно-ориентированного программирования, смысл которой заключается в том, что получение некоторого ресурса неразрывно совмещается с инициализацией объекта, а освобождение — с уничтожением.

  RAII
Другими словами, выделяем память (или любой другой ресурс) в конструкторе некого объекта, а освобождаем - в деструкторе.
  
  Указатель std::shared_ptr используется для управления ресурсами путем совместного владения, т.е. объект, на который указывает shared_ptr, унитожится только после того, как не останется ни одного shared_ptr ссылающегося на него.
  
  std::shared_ptr является копируемым и перемещаемым.
  
  Подсчет ссылок в shared_ptr построен с помощью атомарного счетчика, Можно безопасно использовать указатели лна один и тот же объект из разных потоков. 
  
  ```
  std::shared_ptr ptr(new Image("~/Photo.png));
  
  std::shared_ptr another_ptr = ptr;
  assert(ptr != nullptr);
  assert(another_ptr != nullptr);
  
  std::yet_another_ptr = std::move(ptr);
  assert(ptr == nullptr);
  assert(yet_another_ptr != nullptr);
  ```

## 16) RAII. «Умные» указатели. std::unique_ptr. Примеры.
  RAII см. 15 вопрос
  
  std::unique_ptr - владеет объектом, на который указывает, т.е. отвечает за уничтожение объекта и освобождение памяти.
  
  std::unique_ptr - является некопируемый, но перемещаемым объектом. При попытке копировать std::unique_ptr получим ошибку компиляции.
  
  По умолчанию, std::unique_ptr имеет тот же размер, что и обычные указатели. Для большинства операций выполняются точно такие же команды. Следовательно std::unique_ptr можно использовать, когда важны расход памяти и времени.
  
  Совместим с stl-контейнером. Поддерживает custom deleater.
  
  ``` cpp
  std::unique_ptr ptr(new Image("~/photo.png"));
  std::unique_ptr amother_ptr = std::move(ptr);
  assert(ptr == nullptr);
  assert(another_ptr != nullptr);
  ```
  ## 17) RAII. «Умные» указатели. std::weak_ptr. Примеры.
## 18) Сетевое взаимодействие. Berkley sockets. Основные функции для работы с сокетами
## 19) Сетевое взаимодействие. Сокеты. Библиотека boost asio.
## 20) Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future, функция std::async.
## 21) Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры использования thread_local.
## 22) Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры использования std::thread.
## 23) Синхронизация потоков. Состояние гонок. Классы std::mutex, std::lock_guard, std::unique_lock. Функция std::lock. Примеры использования мьютексов.
## 24) Синхронизация потоков. Состояние гонок. Классы std::recursive_mutex, boost::shared_mutex, std::unique_lock. Функция std::lock. Пример использования std::unique_lock
## 25) Класс std::condition_variable. Потокобезопасные структуры данных с блокировками.
## 26) Синхронизация потоков. Пул потоков. Класс std::condition_variable. Примеры работы с std::condition_variable
## 27) Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future, функция std::async
## 28) Атомарные операции. Классы std::atomic, std::atomic_flag. Примеры работы с std::atomic
## 29) Шаблоны проектирования: фабричный метод. Пример реализации «простой фабрики» и «фабричного метода».
## 30) Шаблоны проектирования: observer. Пример реализации «обозреватель».
## 31) Шаблоны проектирования: синглтон. Пример реализации Синглтона.
## 32) Асинхронное программирование. Плюсы и минусы. Сопрограммы. Функции обратного вызова.
## 33) Атомарные операции. Классы std::atomic. Структуры данных без блокировок. Реализация lock-free stack
  
  
